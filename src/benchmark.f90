module benchmark

! Special treatment for model benchmarks, incluing setting model parameters, creating initial grids,
!! and special climate specifications. Particular benchmarks are labeled with an integer flag. 
!! Currently included benchmarks are:
!!! (1) EISMINT1, fixed margin, steady state. See Huybrechts et al, 1996, Annals of Glaciology
!!! (2) EISMINT1, moving margin, steady state. See Huybrechts et al, 1996, Annals of Glaciology
!!! (3) Bedrock step (or "cliff"). See Jarosch et al 2013, The Cryosphere
!!! (4) Bueler Test A. See Bueler et al 2005, Journal of Glaciology
!!! (5) Bueler Test B. See Bueler et al 2005, Journal of Glaciology
!!! (6) Bueler Test C. See Bueler et al 2005, Journal of Glaciology
!!! (7) Bueler Test D. See Bueler et al 2005, Journal of Glaciology
!!! (8) Bueler Test E. See Bueler et al 2005, Journal of Glaciology
!!! (9)  Egholm Test 1a (0ky).  See Egholm et al 2011, Geomorphology
!!! (10) Egholm Test 1b (5ky).  See Egholm et al 2011, Geomorphology
!!! (11) Egholm Test 1c (10ky). See Egholm et al 2011, Geomorphology
!!! (12) Egholm Test 1d (15ky). See Egholm et al 2011, Geomorphology
!!! (13) Egholm Test 2a (0ky).  See Egholm et al 2011, Geomorphology
!!! (14) Egholm Test 2b (5ky).  See Egholm et al 2011, Geomorphology
!!! (15) Egholm Test 2c (10ky). See Egholm et al 2011, Geomorphology
!!! (16) Egholm Test 2d (15ky). See Egholm et al 2011, Geomorphology

! Hungarian prefixes are used to signify
!! c -> benchmark constant with global scope

! Module contains...
!! benchInitGrids: Setup the initial topography and ice thickness grids for benchmark cases
!! benchSetParams: Set model parameters for benchmark cases
!! benchSurfaceTemp: Compute ice surface temperature for benchmark cases
!! benchBalanceRate: Compute balance rate for the benchmark cases
!! benchSolution: Compute time-dependant exact solutions for benchmark cases, where available

! Version info (auto-generated by svn):
!! $LastChangedDate: 2014-05-10 22:44:34 -0400 (Sat, 10 May 2014) $
!! $LastChangedBy: kfm $
!! $LastChangedRevision: 100 $ 

use types, only: dp
implicit none
private
public benchSurfaceTemp, benchBalanceRate, benchSetParams, benchInitGrids, benchSolution

! Shared constants
real(dp), parameter :: g = 9.81_dp

! Bedrock step benchmark constants
real(dp), parameter :: cStepXm = 20000._dp 
real(dp), parameter :: cStepXs = 7000._dp
real(dp), parameter :: cStepB0 = 500._dp
real(dp), parameter :: cStepMdot0 = 2._dp
real(dp), parameter :: cStepN = 3._dp

! Bueler A benchmark constants
real(dp), parameter :: cBuelaL = 750.e3_dp
real(dp), parameter :: cBuelaM0 = 0.3_dp

! Bueler B benchmark constants
real(dp), parameter :: cBuelbAlpha = 1._dp/9._dp
real(dp), parameter :: cBuelbBeta = 1._dp/18._dp
real(dp), parameter :: cBuelbH0 = 3600
real(dp), parameter :: cBuelbR0 = 750.e3

! Bueler C benchmark constants
real(dp), parameter :: cBuelcAlpha = -1._dp
real(dp), parameter :: cBuelcBeta = 2._dp
real(dp), parameter :: cBuelcH0 = 3600._dp
real(dp), parameter :: cBuelcR0 = 750.e3_dp
real(dp), parameter :: cBuelcTime0 = 15208._dp ! used for end time, elsewhere calculated directly for precision
real(dp), parameter :: cBuelcLambda = 5._dp

! Egholm test 1,2 benchmarks
real(dp), parameter :: cEgholmW  = 1500._dp
real(dp), parameter :: cEgholmL  = 10000._dp
real(dp), parameter :: cEgholmP  = 1.6_dp
real(dp), parameter :: cEgholmA0 = 2._dp
real(dp), parameter :: cEgholmX0 = 1500._dp
real(dp), parameter :: cEgholmX1 = 500._dp
real(dp), parameter :: cEgholmX2 = 4000._dp
real(dp), parameter :: cEgholmTheta  = 0.5_dp
real(dp), parameter :: cEgholmHL = 3000._dp
real(dp), parameter :: cEgholmHT = 1000._dp

! Egholm test 2 benchmarks
real(dp), parameter :: cEgholmHs = 500._dp 
real(dp), parameter :: cEgholmXs = 5000._dp 
real(dp), parameter :: cEgholmDXs = 500._dp 

! Egholm test A benchmarks
real(dp), parameter :: cEgholmATimeEnd = 0._dp 

! Egholm test B benchmarks
real(dp), parameter :: cEgholmBTimeEnd = 5000._dp 

! Egholm test C benchmarks
real(dp), parameter :: cEgholmCTimeEnd = 10000._dp 

! Egholm test D benchmarks
real(dp), parameter :: cEgholmDTimeEnd = 15000._dp 

contains

! ==================================================================================================
! benchSetParams: Set model parameters for benchmark cases
! ==================================================================================================
subroutine benchSetParams( pBenchmark, pRunName, pTopoFile, pIceFile, lNx, fNx, lNy, fNy, fDx, fDy, &
	pDoEros, pDoFlex, pDoTemp, pTimeEnd, pTimeStepIceMax, pTimeStepIceMin, pTimeStep, pWriteFreq, &
	pB, pBs, pGamma, pQheatb, pHeatConduct, pTempSlMin, pTempSlMax, pTempPeriod, pTempLapse, &
	pTempYrRng, pMeltFact, pPrecipRate, pRhoIce, pRhoWater, pRhoCrust, pRhoMantle, pYm, pNu, pTe, &
	pGlacErosFact, pFluvErosFact, pHillD, pUpliftRate, pGlacErosRateCeil, pTFloor, pGlacBcN, &
	pGlacBcS, pGlacBcE, pGlacBcW, pDoGlac, pDoFluv, pDoHill, pDoUplift, pDoTrackIceVol, &
	pDoAddNoise, pDoPrefilter, pFluvBcN, pFluvBcS, pFluvBcE, pFluvBcW, pBaseLvl, &
	pNxPad, pNyPad, pHillBcN, pHillBcS, pHillBcE, pHillBcW, pWriteFlag )

! Arguments:
!! benchmark (in) = integer flag selecting the benchmark case

integer, intent(in) :: pBenchmark
character(len=*), intent(out) :: pRunName, pTopoFile, pIceFile
logical, intent(out) :: pDoGlac, pDoEros, pDoFlex, pDoTemp, pDoFluv, pDoHill, pDoUplift, &
	pDoTrackIceVol, pDoAddNoise, pDoPrefilter
integer, intent(out) :: lNx, fNx, lNy, fNy, pWriteFreq, pGlacBcN, pGlacBcS, pGlacBcE, pGlacBcW, &
	pFluvBcN, pFluvBcS, pFluvBcE, pFluvBcW, pNxPad, pNyPad, pWriteFlag(:), pHillBcN, pHillBcS, &
	pHillBcE, pHillBcW
real(dp), intent(out) :: fDx, fDy, pTimeEnd, pTimeStepIceMax, pTimeStepIceMin, &
	pTimeStep, pB, pBs, pGamma, pQheatb, pHeatConduct, pTempSlMin, pTempSlMax, pTempPeriod, &
	pTempLapse, pTempYrRng, pMeltFact, pPrecipRate, pRhoIce, pRhoWater, pRhoCrust, pRhoMantle, &
	pYm, pNu, pTe, pGlacErosFact, pFluvErosFact, pHillD, pUpliftRate, pGlacErosRateCeil, pTFloor, &
	pBaseLvl

! Initialize all parameters to 0, none, or .false., for unused parameters
pRunName = 'none'; pTopoFile = 'none'; pIceFile = 'none'; lNx = 0; lNy = 0; fNx = 0; fNy = 0.;  
fDx = 0.; fDy = 0.; pDoEros = .false.; pDoFlex = .false.; pDoTemp = .false.; pTimeEnd = 0.;  
pTimeStepIceMax = 0.; pTimeStepIceMin = 0.; pTimeStep = 0.; pWriteFreq = 0; pB = 0.; pBs = 0.; 
pGamma = 0.; pQheatb = 0.; pHeatConduct = 0.; pTempSlMin = 0.; pTempSlMax = 0.; pTempPeriod = 0.; 
pTempLapse = 0.; pTempYrRng = 0.; pMeltFact = 0.; pPrecipRate = 0.; pRhoIce = 0.; pRhoWater = 0.; 
pRhoCrust = 0.; pRhoMantle = 0.; pYm = 0.; pNu = 0.; pTe = 0.; pGlacErosFact = 0.; 
pFluvErosFact = 0.; pHillD = 0.; pUpliftRate = 0.; pGlacErosRateCeil = 0.; pTFloor = 0.; 
pGlacBcN = 0.; pGlacBcS = 0.; pGlacBcE = 0.; pGlacBcW = 0.; pDoGlac = .false.; pDoFluv = .false.; 
pDoHill = .false.; pDoUplift = .false.; pDoTrackIceVol = .false.; pDoAddNoise = .false.; 
pDoPrefilter = .false.; pFluvBcN  = 0; pFluvBcS  = 0.;  pFluvBcE  = 0.; 
pFluvBcW  = 0.; pBaseLvl = 0.; pNxPad = 0; pNyPad = 0; pHillBcN = 0; pHillBcS = 0; pHillBcE = 0; 
pHillBcW = 0; pWriteFlag = 0

select case (pBenchmark)

! EISMINT 1 fixed margin benchmark (unused parameters are not set)
case (1)
	pRunName = 'eismint1f'
	lNx = 29 ! Note: this is 2 smaller than the paper since here the BCs are handled by adding dummy points
	lNy = 29
	fNx = 100 ! size is arbitrary, I use a larger size to test the grid-to-grid interpolation
	fNy = 100
	fDx = 50000._dp*real(lNx-1,dp)/real(fNx-1,dp)
	fDy = 50000._dp*real(lNy-1,dp)/real(fNy-1,dp)
	pDoAddNoise = .false.
	pDoPrefilter = .false.
	pTimeEnd = 1.e5_dp
	pTimeStepIceMax = 100._dp
	pTimeStepIceMin = 0.1_dp
	pTimeStep = 1000._dp
	pWriteFreq = 1
	pDoGlac = .true.
	pDoTemp = .true.
	pB = 1e-16_dp ! Pa^-3 a^-1 
	pQheatb = 42.e-3_dp
	pHeatConduct = 2.1_dp
	pGlacBcN = 0 ! ice-free
	pGlacBcS = 0
	pGlacBcE = 0
	pGlacBcW = 0
	pDoFluv = .false.
	pDoHill = .false.
	pDoFlex = .false.
	pDoEros = .false.
	pDoUplift = .false.
	pRhoIce = 910._dp
	pWriteFlag = &
		[ 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, &
		  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, &
		  0, 0, 0, 1, 0, 0, 1, 0, 0, 1, &
		  0, 0, 0 ] 

! EISMINT 1 moving margin benchmark 
case (2)
	pRunName = 'eismint1m'
	lNx = 29 ! Note: this is 2 smaller than the paper since here the BCs are handled by adding dummy points
	lNy = 29
	fNx = 100 ! Size is arbitrary, I use a larger size to test the grid-to-grid interpolation
	fNy = 100
	fDx = 50000._dp*real(lNx-1,dp)/real(fNx-1,dp)
	fDy = 50000._dp*real(lNy-1,dp)/real(fNy-1,dp)
	pDoAddNoise = .false.
	pDoPrefilter = .false.
	pTimeEnd = 1.e5_dp
	pTimeStepIceMax = 100._dp
	pTimeStepIceMin = 0.1_dp
	pTimeStep = 1000._dp
	pWriteFreq = 1
	pDoGlac = .true.
	pDoTemp = .true.
	pB = 1e-16_dp ! Pa^-3 a^-1 
	pQheatb = 42.e-3_dp
	pHeatConduct = 2.1_dp
	pGlacBcN = 0 ! ice-free
	pGlacBcS = 0
	pGlacBcE = 0
	pGlacBcW = 0
	pDoFluv = .false.
	pDoHill = .false.
	pDoFlex = .false.
	pDoEros = .false.
	pDoUplift = .false.
	pRhoIce = 910._dp
	pWriteFlag = &
		[ 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, &
		  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, &
		  0, 0, 0, 1, 0, 0, 1, 0, 0, 1, &
		  0, 0, 0 ] 

! Bedrock step benchmark
case (3)
	pRunName = 'cliff'
	lNx = 150 ! size is arbitrary, no interpolation to avoid smoothing the step
	fNx = 150
	lNy = 5
	fNy = 5
	fDx = 200._dp
	fDy = 1000._dp
	pDoAddNoise = .false.
	pDoPrefilter = .false.
	pTimeEnd = 1.e4_dp
	pTimeStepIceMax = 100._dp
	pTimeStepIceMin = 0.01_dp
	pTimeStep = 500._dp
	pWriteFreq = 1
	pDoGlac = .true.
	pDoFluv = .false.
	pDoHill = .false.
	pDoFlex = .false.
	pDoEros = .false.
	pDoUplift = .false.
	pDoTemp = .false.
	pB = 1e-16_dp 
	pQheatb = 42.e-3_dp
	pHeatConduct = 2.1_dp
	pGlacBcN = 3 ! cyclic 
	pGlacBcS = 3
	pGlacBcE = 1 ! no-flux
	pGlacBcW = 1
	pRhoIce = 910._dp
	pWriteFlag = &
		[ 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, &
		  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, &
		  0, 0, 0, 1, 0, 1, 1, 0, 0, 1, &
		  0, 0, 0 ] 
		  
! Bueler A benchmark				  
case (4) 
	pRunName = 'buelerA'
	fNx = 60
	fNy = 60
	fDx = 1.1_dp*cBuelaL/(fNx-1) ! makes grid 10% larger than the defined extent of the ice sheet
	fDy = 1.1_dp*cBuelaL/(fNy-1)
	lNx = 60
	lNy = 60
	pTimeEnd = 25.e3_dp
	pTimeStepIceMax = 10._dp 
	pTimeStepIceMin = 0.001_dp
	pTimeStep = 1.e3_dp
	pWriteFreq = 1
	pDoGlac = .true.
	pDoFluv = .false.
	pDoHill = .false.
	pDoFlex = .false.
	pDoEros = .false.
	pDoUplift = .false.
	pB = 1.e-16_dp   
	pGlacBcN = 4
	pGlacBcS = 4
	pGlacBcE = 4
	pGlacBcW = 4
	pRhoIce = 910._dp			
	pWriteFlag = &
		[ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, &
		  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, &
		  0, 0, 0, 0, 0, 1, 0, 0, 0, 0, &
		  0, 0, 0 ] 
		   
! Bueler B benchmark		  
case (5) 
	pRunName = 'buelerB'
	fNx = 60
	fNy = 60
	fDx = 1100.e3_dp/(fNx-1) ! makes grid 1100 km x 1100 km 
	fDy = 1100.e3_dp/(fNy-1)
	lNx = 60
	lNy = 60
	pTimeEnd = 25.e3_dp
	pTimeStepIceMax = 10._dp 
	pTimeStepIceMin = 0.001_dp
	pTimeStep = 100._dp
	pWriteFreq = 1
	pDoGlac = .true.
	pDoFluv = .false.
	pDoHill = .false.
	pDoFlex = .false.
	pDoEros = .false.
	pDoUplift = .false.
	pB = 1.e-16_dp   
	pGlacBcN = 4
	pGlacBcS = 4
	pGlacBcE = 4
	pGlacBcW = 4
	pRhoIce = 910._dp			
	pWriteFlag = &
		[ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, &
		  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, &
		  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, &
		  0, 0, 1 ]  
		 
! Bueler C benchmark		  
case (6) 
	pRunName = 'buelerC'
	fNx = 60
	fNy = 60
	fDx = 825.e3_dp/(fNx-1) ! makes grid 825 km x 825 km 
	fDy = 825.e3_dp/(fNy-1)
	lNx = 60
	lNy = 60
	pTimeEnd = cBuelcTime0
	pTimeStepIceMax = 10._dp 
	pTimeStepIceMin = 0.001_dp
	pTimeStep = 100._dp
	pWriteFreq = 1
	pDoGlac = .true.
	pDoFluv = .false.
	pDoHill = .false.
	pDoFlex = .false.
	pDoEros = .false.
	pDoUplift = .false.
	pB = 1.e-16_dp   
	pGlacBcN = 4
	pGlacBcS = 4
	pGlacBcE = 4
	pGlacBcW = 4
	pRhoIce = 910._dp			
	pWriteFlag = &
		[ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, &
		  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, &
		  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, &
		  0, 0, 1 ]  
	
! Egholm 1a Benchmark	  
case (9) 
	pRunName = 'Egholm_1a'
	fNx = 60
	fNy = 60
	fDx = cEgholmL/(fNx-1) ! makes grid 825 km x 825 km 
	fDy = cEgholmW/(fNy-1)
	lNx = 60
	lNy = 60
	pTimeEnd = cEgholmATimeEnd
	pTimeStepIceMax = 10._dp 
	pTimeStepIceMin = 0.001_dp
	pTimeStep = 100._dp
	pWriteFreq = 1
	pDoGlac = .true.
	pDoFluv = .false.
	pDoHill = .false.
	pDoFlex = .false.
	pDoEros = .true. 
	pDoUplift = .false.
	pB = 1.e-16_dp   
	pGlacBcN = 4
	pGlacBcS = 4
	pGlacBcE = 4
	pGlacBcW = 4
	pRhoIce = 910._dp
	pWriteFlag = &
		[ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1 ]  

! Egholm 1b Benchmark	  
case (10) 
	pRunName = 'Egholm_1b'
	fNx = 60
	fNy = 60
	fDx = cEgholmL/(fNx-1) ! makes grid 825 km x 825 km 
	fDy = cEgholmW/(fNy-1)
	lNx = 60
	lNy = 60
	pTimeEnd = cEgholmBTimeEnd
	pTimeStepIceMax = 10._dp 
	pTimeStepIceMin = 0.001_dp
	pTimeStep = 100._dp
	pWriteFreq = 1
	pDoGlac = .true.
	pDoFluv = .false.
	pDoHill = .false.
	pDoFlex = .false.
	pDoEros = .true. 
	pDoUplift = .false.
	pB = 1.e-16_dp   
	pGlacBcN = 4
	pGlacBcS = 4
	pGlacBcE = 4
	pGlacBcW = 4
	pRhoIce = 910._dp
	pWriteFlag = &
		[ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1 ]  

! Egholm 1c Benchmark	  
case (11) 
	pRunName = 'Egholm_1c'
	fNx = 60
	fNy = 60
	fDx = cEgholmL/(fNx-1) ! makes grid 825 km x 825 km 
	fDy = cEgholmW/(fNy-1)
	lNx = 60
	lNy = 60
	pTimeEnd = cEgholmCTimeEnd
	pTimeStepIceMax = 10._dp 
	pTimeStepIceMin = 0.001_dp
	pTimeStep = 100._dp
	pWriteFreq = 1
	pDoGlac = .true.
	pDoFluv = .false.
	pDoHill = .false.
	pDoFlex = .false.
	pDoEros = .true. 
	pDoUplift = .false.
	pB = 1.e-16_dp   
	pGlacBcN = 4
	pGlacBcS = 4
	pGlacBcE = 4
	pGlacBcW = 4
	pRhoIce = 910._dp
	pWriteFlag = &
		[ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1 ]  

! Egholm 1d Benchmark	  
case (12) 
	pRunName = 'Egholm_1d'
	fNx = 60
	fNy = 60
	fDx = cEgholmL/(fNx-1) ! makes grid 825 km x 825 km 
	fDy = cEgholmW/(fNy-1)
	lNx = 60
	lNy = 60
	pTimeEnd = cEgholmDTimeEnd
	pTimeStepIceMax = 10._dp 
	pTimeStepIceMin = 0.001_dp
	pTimeStep = 100._dp
	pWriteFreq = 1
	pDoGlac = .true.
	pDoFluv = .false.
	pDoHill = .false.
	pDoFlex = .false.
	pDoEros = .true.
	pDoUplift = .false.
	pB = 1.e-16_dp   
	pGlacBcN = 4
	pGlacBcS = 4
	pGlacBcE = 4
	pGlacBcW = 4
	pRhoIce = 910._dp
	pWriteFlag = &
		[ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1 ]  

! Egholm 2a Benchmark	  
case (13) 
	pRunName = 'Egholm_2a'
	fNx = 60
	fNy = 60
	fDx = cEgholmL/(fNx-1) ! makes grid 825 km x 825 km 
	fDy = cEgholmW/(fNy-1)
	lNx = 60
	lNy = 60
	pTimeEnd = cEgholmATimeEnd
	pTimeStepIceMax = 10._dp 
	pTimeStepIceMin = 0.001_dp
	pTimeStep = 100._dp
	pWriteFreq = 1
	pDoGlac = .true.
	pDoFluv = .false.
	pDoHill = .false.
	pDoFlex = .false.
	pDoEros = .true. 
	pDoUplift = .false.
	pB = 1.e-16_dp   
	pGlacBcN = 4
	pGlacBcS = 4
	pGlacBcE = 4
	pGlacBcW = 4
	pRhoIce = 910._dp
	pWriteFlag = &
		[ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1 ]  

! Egholm 2b Benchmark	  
case (14) 
	pRunName = 'Egholm_2b'
	fNx = 60
	fNy = 60
	fDx = cEgholmL/(fNx-1) ! makes grid 825 km x 825 km 
	fDy = cEgholmW/(fNy-1)
	lNx = 60
	lNy = 60
	pTimeEnd = cEgholmBTimeEnd
	pTimeStepIceMax = 10._dp 
	pTimeStepIceMin = 0.001_dp
	pTimeStep = 100._dp
	pWriteFreq = 1
	pDoGlac = .true.
	pDoFluv = .false.
	pDoHill = .false.
	pDoFlex = .false.
	pDoEros = .true. 
	pDoUplift = .false.
	pB = 1.e-16_dp   
	pGlacBcN = 4
	pGlacBcS = 4
	pGlacBcE = 4
	pGlacBcW = 4
	pRhoIce = 910._dp
	pWriteFlag = &
		[ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1 ]  

! Egholm 2c Benchmark	  
case (15) 
	pRunName = 'Egholm_2c'
	fNx = 60
	fNy = 60
	fDx = cEgholmL/(fNx-1) ! makes grid 825 km x 825 km 
	fDy = cEgholmW/(fNy-1)
	lNx = 60
	lNy = 60
	pTimeEnd = cEgholmCTimeEnd
	pTimeStepIceMax = 10._dp 
	pTimeStepIceMin = 0.001_dp
	pTimeStep = 100._dp
	pWriteFreq = 1
	pDoGlac = .true.
	pDoFluv = .false.
	pDoHill = .false.
	pDoFlex = .false.
	pDoEros = .true. 
	pDoUplift = .false.
	pB = 1.e-16_dp   
	pGlacBcN = 4
	pGlacBcS = 4
	pGlacBcE = 4
	pGlacBcW = 4
	pRhoIce = 910._dp
	pWriteFlag = &
		[ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1 ]  

! Egholm 2d Benchmark	  
case (16) 
	pRunName = 'Egholm_2d'
	fNx = 60
	fNy = 60
	fDx = cEgholmL/(fNx-1) ! makes grid 825 km x 825 km 
	fDy = cEgholmW/(fNy-1)
	lNx = 60
	lNy = 60
	pTimeEnd = cEgholmDTimeEnd
	pTimeStepIceMax = 10._dp 
	pTimeStepIceMin = 0.001_dp
	pTimeStep = 100._dp
	pWriteFreq = 1
	pDoGlac = .true.
	pDoFluv = .false.
	pDoHill = .false.
	pDoFlex = .false.
	pDoEros = .true. 
	pDoUplift = .false.
	pB = 1.e-16_dp   
	pGlacBcN = 4
	pGlacBcS = 4
	pGlacBcE = 4
	pGlacBcW = 4
	pRhoIce = 910._dp
	pWriteFlag = &
		[ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &
		  1, 1, 1 ]  

	
end select

return
end subroutine benchSetParams

! ==================================================================================================
! benchInitGrids: Setup the initial topography and ice thickness grids for benchmark cases
! ==================================================================================================
subroutine benchInitGrids( benchmark, x, y, t, h, b, rhoIce )

! Arguments
!! benchmark (in) = integer flag incidating the benchmark case
!! x (in) = high-res x-coordinate grid
!! y (in) = high-res y-coordinate grid
!! t (out) = high-res topography grid
!! h (out) = high-res ice-thickness grid
!! b (in) = ice deformation rate constant
!! rhoIce (in) =  ice density

integer, intent(in) :: benchmark
real(dp), intent(in) :: x(:,:), y(:,:), b, rhoIce
real(dp), intent(out) :: t(:,:), h(:,:)

integer :: nx, ny
real(dp) :: c1, c2, hsp, hsn, gamma, time0
real(dp), allocatable :: r(:,:), c(:,:)

! Get grid size
nx = size(t,1)
ny = size(t,2)

select case (benchmark)

	! EISMINT 1 fixed margin
	case (1) 
		t = 0._dp
		h = 0._dp
		
	! EISMINT 1 moving margin
	case (2)
		t = 0._dp
		h = 0._dp
	
	! Bedrock step
	case (3)
		
		!! Topography is a cStepB0 high bedrock step at cStepXs 
		!!! Note: Since elevation==0 at cStepXs, the ice thickness there is hsp
		where (x<cStepXs) 
			t = cStepB0
		elsewhere
			t = 0._dp
		end where	
		h = 0._dp
		
		!! Initial ice thickness is the exact solution at steady state from Jarosch et al 2013, 
		!!! Cryosphere (section 6, pg 236).
		!!! Constants, for simplicity
		c1 = ((2._dp*cStepN+2._dp)*(cStepN+2._dp)**(1._dp/cStepN)*cStepMdot0**(1._dp/cStepN)) / &
			(2._dp**(1._dp/cStepN)*6._dp*cStepN*b**(1._dp/cStepN)*rhoIce*g*cStepXm**((2._dp*cStepN-1._dp)/cStepN))
		c2 = (cStepN/(2._dp*cStepN+2._dp))
		!! At cStepXs, from positive and negative sides
		hsp = ( c1*(cStepXm+2._dp*cStepXs)*(cStepXm-cStepXs)**2._dp )**c2  
		hsn = max(hsp-cStepB0, 0._dp)	
		!! Above the step
		where (x<cStepXs) &
			h = ( hsn**(1._dp/c2) - hsp**(1._dp/c2) + c1*(cStepXm+2._dp*x)*(cStepXm-x)**2._dp )**c2
		!! At the step (two options at the discontinuty)
		where (x==cStepXs) h = hsp
		!! Below the step
		where ((x>cStepXs).and.(x<cStepXm)) h = ( c1*(cStepXm+2._dp*x)*(cStepXm-x)**2._dp )**c2
		!! Beyond the terminus
		where (x>=cStepXm) h = 0._dp
	
	! Bueler  A (a.k.a. Vialov)	
	case (4) 
	
		!! Flat topography
		t = 0._dp
		
		!! Initial thickness is a 750 km radius ice cap
		allocate(r(nx,ny))
		r = sqrt(x**2+y**2)
		gamma = 2._dp/5._dp*b*(rhoIce*g)**3._dp 
		where (r<cBuelaL) 
			h = (2._dp**2._dp*cBuelaM0/gamma)**(1._dp/8) * &
				(cBuelaL**(4._dp/3._dp)-r**(4._dp/3._dp))**(3._dp/8._dp)
		elsewhere
			h = 0._dp
		end where	
		deallocate(r)
		
	! Bueler B (a.k.a. Halfar)	
	case (5)
		
		!! Flat topography
		t = 0._dp
		
		!! Initial thickness is evaluated at time0
		allocate(r(nx,ny), c(nx,ny))
		r = sqrt(x**2+y**2)
		gamma = 2._dp/5._dp*b*(rhoIce*g)**3._dp 
		time0 = cBuelbBeta/gamma*(7._dp/4._dp)**3._dp*cBuelbR0**4._dp/cBuelbH0**7._dp
		c = 1._dp-(r/cBuelbR0)**(4._dp/3._dp)
		where (c>=0._dp)
			h = cBuelbH0*c**(3._dp/7._dp)
		elsewhere
			h = 0._dp
		end where
		deallocate(r,c)
	
	! Bueler C	
	case(6)	
		t = 0._dp
		h = 0._dp
		

        ! Egholm 1
        case(9:12)
                !!Get ice from steady state
                h = 0._dp
                t = cEgholmHL * (1 - (x/cEgholmL) ** cEgholmTheta) + cEgholmHT * ((abs(y - (cEgholmW / 2)) / cEgholmW) ** cEgholmP)

        ! Egholm 2
        case(13:16)
                !!Get ice from steady state
                h = 0._dp
                t = cEgholmHL * (1 - (x/cEgholmL) ** cEgholmTheta) + cEgholmHT * ((abs(y - (cEgholmW / 2)) / cEgholmW) ** cEgholmP) - (cEgholmHS/2) * (erf((x - cEgholmXS) / cEgholmDXS) + 1) * ( 1 - (abs(y - (cEgholmW /2)) / cEgholmW))


end select
	
return
end subroutine benchInitGrids

! ==================================================================================================
! benchSurfaceTemp: Compute ice surface temperature for benchmark cases
! ==================================================================================================
subroutine benchSurfaceTemp( benchmark, jSta, jEnd, dx, dy, ht, tempS)

! Arguments:
!! benchmark (in) = integer lable that selects the particular benchmark
!! jSta, jEnd (in) = first and last rows handled by this thread
!! dx, dy (in) = grid spacing
!! ht (in) = ice surface topography grid, m
!! tempS (out) = ice surface temperature, C

integer, intent(in) :: benchmark, jSta, jEnd
real(dp), intent(in) :: dx, dy, ht(:,:)
real(dp), intent(out) :: tempS(:,:)

integer :: nx, ny, j0, j1, i, j
real(dp) :: dist

! Get grid dimensions & limits
nx = size(tempS,1)
ny = size(tempS,2)
j0 = max(2,jSta); j1 = min(ny-1,jEnd) ! Interior points in proc range only

select case (benchmark)
	
	! EISMINT 1 fixed margin
	case (1) 
		do j = j0,j1
			do i = 2,nx-1			
				dist = max( abs(dx*(i-1)-750000._dp), abs(dy*(j-1)-750000._dp) )/1.e3_dp;
		        tempS(i,j) = -34.15_dp+8.e-8_dp*dist**3._dp;	        
			end do
		end do
	
	! EISMINT 1 moving margin
	case (2)
		do j = j0,j1
			do i = 2,nx-1			
				tempS(i,j) = -3.15_dp-0.01_dp*ht(i,j);	        
			end do
		end do
	
	! Bedrock step
	case (3) 
		!! no temperature calculations needed
	
	! Bueler A
	case (4) 
		!! no temperature calculations needed
		
	! Bueler B
	case (5) 
		!! no temperature calculations needed
		
	! Bueler C
	case (6) 
		!! no temperature calculations needed
		
	! Bueler D
	case (7) 
		!! no temperature calculations needed
		
	! Bueler E
	case (8) 
		!! no temperature calculations needed	
		
        ! Egholm 1
        case(9:12)
		!! no temperature calculations needed	
        
        ! Egholm 2
        case(13:16)
		!! no temperature calculations needed	
		
	end select	



return	
end subroutine benchSurfaceTemp

! ==================================================================================================
! benchBalanceRate: Compute balance rate for the benchmark cases
! ==================================================================================================
subroutine benchBalanceRate( benchmark, jSta, jEnd, dx, dy, x, y, time, b, rhoIce, snowRate, &
	meltRate )

! Arguments:
!! benchmark (in) = integer lable that selects the particular benchmark
!! jSta, jEnd (in) = first and last rows handled by this thread
!! dx, dy (in) = grid spacing, m
!! x, y (in) = x- and y-coordinate grids
!! time (in) = current model time, yrs
!! snowRate (out): Positive part of the balance rate grid, m_ice/yr
!! meltRate (out): Negative part of the balance rate grid, m_ice/yr

integer, intent(in) :: benchmark, jSta, jEnd
real(dp), intent(in) :: dx, dy, x(:,:), y(:,:), time, b, rhoIce
real(dp), intent(out) :: snowRate(:,:), meltRate(:,:)

integer :: i, j, j0, j1, nx, ny
real(dp) :: dist, gamma, time0, timeRatio
real(dp), allocatable :: r(:,:), c(:,:), h(:,:)
save :: r

! Get grid dimensions & limits
nx = size(snowRate,1)
ny = size(snowRate,2)
j0 = max(2,jSta); j1 = min(ny-1,jEnd) ! interior points only

select case (benchmark)

! EISMINT 1 fixed margin benchmark
case (1)
	snowRate = 0.3_dp
	meltRate = 0._dp
	
! EISMINT 1 moving margin benchmark
case (2)
	do j = j0,j1
		do i = 2,nx-1
			dist = sqrt( (dx*(i-1)-750000._dp)**2._dp + (dy*(j-1)-750000._dp)**2._dp )/1.e3_dp;
			snowRate(i,j) = max( min(0.5_dp, 0.01_dp*(450._dp-dist)), 0._dp )	
			meltRate(i,j) = -min( min(0.5_dp, 0.01_dp*(450._dp-dist)), 0._dp )	
		end do
	end do

! Bedrock step benchmark
case (3)
	do i = 2,nx-1
		do j = j0,j1
			if (x(i,j)<cStepXm) then
				!! snowRate is temporarily used to hold the full mass balance term
				snowRate(i,j) = (cStepN*cStepMdot0)/cStepXm**(2._dp*cStepN-1._dp)*&
					x(i,j)**(cStepN-1._dp)*abs(cStepXm-x(i,j))**(cStepN-1._dp)*(cStepXm-2._dp*x(i,j))
			else
				!! NOTE: this is not written up in Jarosch et al, but is included in the supplemental 
				!!! python code for figure 3. Without the truncation, ice extent is limited by excessive
				!!! negative balance rates.
				snowRate(i,j) = 0._dp
			end if
		end do 
	end do	
	!! Split into positive and negative parts
	meltRate(:,j0:j1) = -min( snowRate(:,j0:j1), 0._dp )
	snowRate(:,j0:j1) = max( snowRate(:,j0:j1), 0._dp )
	
! Bueler A, exact balance rate
case (4)
	
	!! Compute radial distance, once
	if (allocated(r) .eqv. .false.) then
		allocate( r(nx,ny) )
		r = sqrt(x**2._dp+y**2._dp)
	end if
	!! Compute balance rate
	where (r(:,j0:j1)<cBuelaL)
		snowRate(:,j0:j1) = 0.3_dp
		meltRate(:,j0:j1) = 0._dp
	elsewhere
		snowRate(:,j0:j1) = 0._dp
		meltRate(:,j0:j1) = huge(0._dp) ! arbitrarily large, melt everything outside of the pre-defined icecap
	end where
	
! Bueler B, exact balance rate	
case (5)
	!! zero accumulation
	snowRate(:,j0:j1) = 0._dp
	meltRate(:,j0:j1) = 0._dp

! Bueler C, exact balance rate
case (6)	

	!! Compute radial distance, once
	if (allocated(r) .eqv. .false.) then
		allocate( r(nx,ny) )
		r = sqrt(x**2._dp+y**2._dp)
	end if
	
	!! Compute exact ice thickness
	allocate( c(nx,ny), h(nx,ny) )
	gamma = 2._dp/5._dp*b*(rhoIce*g)**3._dp 
	time0 = cBuelcBeta/gamma*(7._dp/4._dp)**3._dp*cBuelcR0**4._dp/cBuelcH0**7._dp
	timeRatio = time/time0
	c(:,j0:j1) = 1-(timeRatio**(-cBuelcBeta)*r(:,j0:j1)/cBuelcR0)**(4._dp/3._dp)
	where (c(:,j0:j1)>0._dp)
		h(:,j0:j1) = cBuelcH0*timeRatio**(-cBuelcAlpha)*c(:,j0:j1)**(3._dp/7._dp)
	elsewhere
		h(:,j0:j1) = 0._dp
	end where	
	
	!! Compute balance rate
	!!! snowRate is temporarily used to hold both positive and negative parts
	snowRate(:,j0:j1) = cBuelcLambda/time*h(:,j0:j1)
	!! Split into positive and negative parts
	meltRate(:,j0:j1) = -min( snowRate(:,j0:j1), 0._dp )
	snowRate(:,j0:j1) = max( snowRate(:,j0:j1), 0._dp )	
	deallocate( c, h )
	
!Egholm1,2
case(9:16)	
	!! Compute balance rate
	!!! snowRate is temporarily used to hold both positive and negative parts
        where (x(:,j0:j1) > cEgholmX0)
                snowRate(:,j0:j1) =  cEgholmA0 * (((x(:,j0:j1) - cEgholmX1) /(cEgholmX0 - cEgholmX1)) - (abs(y(:,j0:j1) - (cEgholmW / 2))/cEgholmW)**cEgholmP ) 
        elsewhere
                snowRate(:,j0:j1) = cEgholmA0 * (((cEgholmX2 - x(:,j0:j1))/(cEgholmX2 - cEgholmX0)) - (abs(y(:,j0:j1) - (cEgholmW / 2))/cEgholmW)**cEgholmP ) 
        end where

	!! Split into positive and negative parts
	meltRate(:,j0:j1) = -min( snowRate(:,j0:j1), 0._dp )
	snowRate(:,j0:j1) =  max( snowRate(:,j0:j1), 0._dp )	
	
end select

return
end subroutine benchBalanceRate

! ==================================================================================================
! benchSolution: Compute time-dependant exact solutions for benchmark cases, where available
! ==================================================================================================
subroutine benchSolution( benchmark, x, y, b, rhoIce, time, h )

! Arguments:
!! benchmark (in) = integer lable that selects the particular benchmark
!! x, y (in) = x- and y-coordinate grids
!! b (in) = ice deformation rate constant
!! rhoIce (in) =  ice density, kg/m^3
!! time (in) = current model time, yrs
!! h (out) = exact solution for ice thickness

integer, intent(in) :: benchmark
real(dp), intent(in) :: x(:,:), y(:,:), b, rhoIce, time
real(dp), intent(out) :: h(:,:)

integer :: nx, ny
real(dp) :: gamma, time0, timeRatio
real(dp), allocatable :: r(:,:), c(:,:)
save :: r

! Get grid size
nx = size(h,1)
ny = size(h,2)

select case(benchmark)

! EISMINT1 fixed margin
case (1) 
	!! No time-dependant solution

! EISMINT1 moving margin
case (2) 
	!! No time-dependant solution

! Bedrock step
case (3)
	!! No time-dependant solution

! Bueler A
case (4)
	!! No time-dependant solution

! Bueler B 
case (5) 
	
	! Compute radial distance, once
	if (allocated(r) .eqv. .false.) then
		allocate( r(nx,ny) )
		r = sqrt(x**2._dp+y**2._dp)
	end if
	
	! Compute ice thickness
	allocate( c(nx,ny) )
	gamma = 2._dp/5._dp*b*(rhoIce*g)**3._dp 
	time0 = cBuelbBeta/gamma*(7._dp/4._dp)**3._dp*cBuelbR0**4._dp/cBuelbH0**7._dp
	timeRatio = (time+time0)/time0
	print*,timeRatio
	c = 1-(timeRatio**(-cBuelbBeta)*r/cBuelbR0)**(4._dp/3._dp)
	where (c>0._dp)
		h = cBuelbH0*timeRatio**(-cBuelbAlpha)*c**(3._dp/7._dp)
	elsewhere
		h = 0._dp
	end where
	deallocate( c )
	
! Bueler C	
case(6)

	! Compute radial distance, once
	if (allocated(r) .eqv. .false.) then
		allocate( r(nx,ny) )
		r = sqrt(x**2._dp+y**2._dp)
	end if
	
	! Compute ice thickness
	allocate( c(nx,ny) )
	gamma = 2._dp/5._dp*b*(rhoIce*g)**3._dp 
	time0 = cBuelcBeta/gamma*(7._dp/4._dp)**3._dp*cBuelcR0**4._dp/cBuelcH0**7._dp
	timeRatio = time/time0
	print*,timeRatio
	c = 1-(timeRatio**(-cBuelcBeta)*r/cBuelcR0)**(4._dp/3._dp)
	where (c>0._dp)
		h = cBuelcH0*timeRatio**(-cBuelcAlpha)*c**(3._dp/7._dp)
	elsewhere
		h = 0._dp
	end where
	deallocate( c )
	
!Egholm1,2
case(9:16)
	!! No time-dependant solution

end select

end subroutine benchSolution

end module benchmark
