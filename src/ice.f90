module ice

! Numerical model of glaciation, modified from the ICE model of Braun et al. (1997, Annals of 
!! Glaciology) and Herman et al (2008, JGR). Changes include using the "Method 1" discretization of 
!! Hindmarsh et al (1996, Annals of Glaciology), positive-degree-day mass balance calculations based
!! on Kessler et al (2006, JGR), and a novel flux-limiting method derived from Wang et al (2011, 
!! Fluids & Computers). 

! Note: Runs in parallel using MPI, which must be initialized (mpi_init) and closed (mpi_finalize) 
!! in the calling program.

! "Hungarian" prefixes are used to indicate the inteded usage of the variable:
!! p -> input parameter
!! f -> full-resolution grid
!! l -> low-resolution grid

! Module contains...
!! runIce: main ice model, computes evolving ice thickness and the ice velocity field
!! applyBc: apply the specified n,s,e,w boundary conditions
!! balanceRate: Compute ice & water balance using a positive-degree-day scheme
!! basalTemp: Compute temperatures at the glacier bed
!! lowToHighRes: linear interpolation of low-res data onto high-res grid
!! meltingTemp: Compute the pressure melting point at the base of the glacier
!! paraRange: Divide up array row-by-row for parallel processing
!! updateHeight: Computes ice thickness change due to deformation and sliding
!! spatial2ndDerivSg: Compute the spatial second derivatives of topography on the staggered grid 
!! trackIceVol: Keep track of ice volume input and loss during each step of the ice model
!! smoothGrid: 9-pt weighted average smoothing filter

! Version info (auto-generated by svn):
!! $LastChangedDate: 2014-05-10 22:44:34 -0400 (Sat, 10 May 2014) $
!! $LastChangedBy: kfm $
!! $LastChangedRevision: 100 $ 

use types, only: dp, dp_mpi, dp_eps 
use mpi, only: mpi_status_size, mpi_comm_world, mpi_proc_null, mpi_min, mpi_sum
use ieee_arithmetic
use benchmark, only: benchSurfaceTemp, benchBalanceRate
implicit none
private
public runIce, highToLowRes, lowToHighRes

real(dp), parameter :: pi = atan(1._dp)*4._dp
real(dp), parameter :: dayInYr = 365.25_dp 
real(dp), parameter :: secInYr = 365.25_dp*24._dp*3600._dp

contains

! ==================================================================================================
! runIce: main ice model, computes evolving ice thickness and the ice velocity field
! ==================================================================================================
subroutine runIce ( pTimeStart, pTimeEnd, pTimeStepMax, pTimeStepMin, pB, pC, pCs, pGamma, pDoTemp, &
	pTempBasalGrad, pTempDiffuse, pTempSlMin, pTempSlMax, pTempPeriod, pTempLapse, pPrecipRate, &
	pTempYrRng, pMeltFact, pRhoIce, pRhoWater, pBenchmark, lX, lY, lDx, lDy, fX, fY, fDx, fDy, fT, &
	lH, lHT, fH, fHT, lTempS, lTempB, lTempM, lBalRate, lT, lUDefm, lVDefm, lUSlid, lVSlid, &
	lSliding, fSliding, lConstrict, dvolSrc, dvolSnk, dvol, pBcN, pBcS, pBcE, pBcW, pDoTrackVol, &
	fIceFree, fErosRate, erosRateCeil, erosFact, fWater, timeStepMean, tempSl )

! Arguments:
!! timeStart, timeEnd (in): model start and end time, start matters for climate calculation only
!! pTimeStepMax (in): the maximum allowed model timestep
!! pB (in) = ice deformation rate constant
!! pC, pCs (in): combined constants for the shallow-ice deformation and Kamb sliding relation, repectively
!!! includes all of the scalar constants (i.e. pC = 2.*b*(pRhoIce*g)**3./(3.+2.) )
!! pGamma (in): valley constriction constant
!! pDoTemp (in): flag for temperature calculations, polythermal glacier bed if .true.
!! pTempBasalGrad (in): glacier bed temperature gradient
!! pTempDiffuse (in): ice thermal diffusivity
!! pTempSlMin (in), pTempSlMax: min, max sea level temperature over a sinusoidal cycle, deg. C
!! pTempPeriod (in): period for sinusoidal temperature oscillation, yrs
!! pTempLapse (in): atmospheric temperature lapse rate
!! pPrecipRate (in): precipitation rate, m(water)/yr 
!! pTempYrRng (in): amplitude of annual sinusoidal temperature cycle, deg. C
!! pMeltFact (in): melting rate constant, m(ice)/day/deg. C 	
!! pRhoIce, pRhoWater (in): densities
!! pBenchmark (in): selects whether to run a benchmark model, which alters the balance rate, temp and pBcS
!! lX, lY (in): low-res coordinate grids
!! lDx, lDy (in): spacing for low-res grid
!! fX, fY (in): high-res coordinate grids
!! fDx, fDy (in): spacing for high-res grid
!! fT (in): high-res bedrock topography
!! pBcN, pBcS, pBcE, pBcW (in): selects the type of boundary condition for n,s,e,w boundaries, see applyBc
!! pDoTrackVol (in): flag for ice volume tracking
!! erosRateCeil (in): upper limit for the glacial erosion rate 
!! erosFact (in): glacial erosion law rate constant
!! lH (inout): low-res ice thickness
!! lHT (inout): low-res ice surface topography: 
!! fH (out): high-res ice thickness
!! fHT (out): high-res ice surface topography
!! lTempS (out): low-res surface temperature	
!! lTempB (out): low-res basal temperature
!! lTempM (out): low-res ice melting temperature ate the glacier bed
!! lBalRate (out): low-res balance rate
!! lT (out): low-res bedrock topography
!! lUDefm, lVDefm (out): low-res ice deformation velocity components
!! lUSlid, lVSlid (out): low-res ice sliding velocity components
!! lSliding (out): low-res sliding velocity magnitude
!! fSliding (out): high-res sliding velocity magnitude 
!! lConstrict (out): low-res valley constriction factor
!! dvol (out): change in ice volume
!! dvolSrc (out): total ice volume added by precipitation and flux through domain boundaries 
!! dvolSnk (out): total ice volume added by melt and flux through domain boundaries 
!! (NOTE: Ice mass is conserved if dvol == dvolSrc+dvolSnk)
!! fIceFree (out): logical mask for icy points
!! fErosRate (out): glacial erosion rate
!! fWater (out): effective precipitation rate in m/yr, including rain and melt, but not perenial snow
!! timeStepMean (out): average timestep used

logical, intent(in) :: pDoTemp, pDoTrackVol
integer, intent(in) :: pBenchmark, pBcN, pBcS, pBcE, pBcW
real(dp), intent(in) :: pTimeStepMax, pTimeStepMin, pTimeStart, pTimeEnd, lDx, lDy, fDx, fDy, &
	pTempSlMin, pTempSlMax, pTempPeriod, pTempLapse, pRhoIce, pRhoWater, pPrecipRate, pTempYrRng, &
	pMeltFact, lX(:,:), pTempBasalGrad, pTempDiffuse, pC, pCs, fT(:,:), lY(:,:), fX(:,:), fY(:,:), &
	pGamma, erosRateCeil, erosFact, pB
real(dp), intent(inout) :: lH(:,:), lHT(:,:) 
logical, intent(out) :: fIceFree(:,:)
real(dp), intent(out) :: dvolSrc, dvolSnk, dvol, lTempS(:,:), lTempB(:,:), lTempM(:,:), &
	lBalRate(:,:), lT(:,:), fH(:,:), fHT(:,:), lSliding(:,:), fSliding(:,:), lUDefm(:,:), &
	lVDefm(:,:), lUSlid(:,:), lVSlid(:,:), lConstrict(:,:), fErosRate(:,:), fWater(:,:), &
	timeStepMean, tempSl

integer :: lNx, lNy, fNx, fNy, ierr, proc, numProc, jSta, jEnd, next, prev, ip, step, &
	request2(2), status2(mpi_status_size,2)
integer, allocatable :: idisp(:), jjlen(:)
real(dp) :: time, initVol, timeStep, work
real(dp), allocatable :: qx(:,:), qy(:,:), lRain(:,:), lSnow(:,:), lMelt(:,:), &
	lWater(:,:), dtdxx(:,:), dtdyy(:,:), dtdxy(:,:), lDhdt(:,:)

! Setup parallelization
call mpi_comm_size( mpi_comm_world, numProc, ierr )
call mpi_comm_rank( mpi_comm_world, proc, ierr )
next = proc + 1
prev = proc - 1
if (proc == numProc - 1) next = mpi_proc_null
if (proc == 0) prev = mpi_proc_null

! Get grid dimensions
lNx = size(lH,1)
lNy = size(lH,2)
fNx = size(fT,1)
fNy = size(fT,2)
allocate( qx(lNx-1,lNy-2), qy(lNx-2,lNy-1), lRain(lNx,lNy), lSnow(lNx,lNy), lMelt(lNx,lNy), &
	lWater(lNx,lNy), dtdxx(lNx-1,lNy-1), dtdyy(lNx-1,lNy-1), dtdxy(lNx-1,lNy-1), lDhdt(lNx,lNy) )

! Setup ranges for parallel threads
allocate (idisp(0:numProc-1), jjlen(0:numProc-1))
do ip = 0, numProc - 1
	call paraRange(1,lNy,numProc,ip,jSta,jEnd)
	jjlen(ip) = lNx * (jEnd - jSta + 1)
	idisp(ip) = lNx * (jSta - 1)
enddo
call paraRange(1,lNy,numProc,proc,jSta,jEnd)

! High-res -> low-res topography 		
call highToLowRes ( lX, fX, lY, fY, fDx, fDy, lT, fT ) 
call applyBc( pBcN, pBcS, pBcE, pBcW, lH, lT, jSta, jEnd, proc, numProc-1 ) ! populate bcs 

! Compute the spatial 2nd derivatives of the topography, used for compute the constriction factor
call spatial2ndDerivSg ( lT, lDx, lDy, dtdxx, dtdxy, dtdyy )

! Enter main loop
step = 0
time = pTimeStart
dvolSrc = 0._dp ! to track mass conservation
dvolSnk = 0._dp	
timeStep = pTimeStepMax
initVol = sum(lH(2:lNx-1,2:lNy-1))*lDx*lDy	
lWater = 0._dp

do while (time<pTimeEnd)
	
	! Apply boundary condition
	call applyBc( pBcN, pBcS, pBcE, pBcW, lH, lT, jSta, jEnd, proc, numProc-1 ) 
	
	! Ice surface topography	
	where (lH(:,jSta:jEnd)>0._dp)
		lHT(:,jSta:jEnd) = lH(:,jSta:jEnd)+lT(:,jSta:jEnd)
	elsewhere
		lHT(:,jSta:jEnd) = lT(:,jSta:jEnd)
	end where	
	!! Share first row upwards with prev proc
	call mpi_isend(lHT(1,jSta), lNx, dp_mpi, prev, 11, mpi_comm_world, request2(1), ierr)	
        if (next .ne. mpi_proc_null) &
	        call mpi_irecv(lHT(1,jEnd+1), lNx, dp_mpi, next, 11, mpi_comm_world, request2(2), ierr)	
	call mpi_waitall(2, request2, status2, ierr)
			
	! Climate forcing
	!! Normal model
	if (pBenchmark==0) then
		call surfaceTemp( jSta, jEnd, time, pTempSlMin, pTempSlMax, pTempPeriod, pTempLapse, lHT, &
			lTempS, tempSl )			
		call balanceRate( jSta, jEnd, pRhoIce, pRhoWater, pPrecipRate, pTempYrRng, pMeltFact, &
			lTempS, lRain, lSnow, lMelt )			
	!! Benchmarks		
	else
		call benchSurfaceTemp( pBenchmark, jSta, jEnd, lDx, lDy, lHT, lTempS)
		call benchBalanceRate( pBenchmark, jSta, jEnd, lDx, lDy, lX, lY, time, pB, pRhoIce, lSnow, &
			lMelt )
	end if
	!! Do polythermal ice calculations (otherwise slide everywhere)
	if (pDoTemp) then 
		call basalTemp ( jSta, jEnd, pTempBasalGrad, pTempDiffuse, lTempS, (lSnow-lMelt), &
			lH, lTempB )
		call meltingTemp ( jSta, jEnd, lNx, lNy, lH, lTempM )
	end if
	!! No sharing needed
	
	! Update ice thickness
	call updateHeight ( jSta, jEnd, next, prev, pDoTemp, pC, pCs, lDx, lDy, lT, lH, lHT, lTempB, &
		lTempM, timeStep, qx, qy, dtdxx, dtdyy, dtdxy, pGamma, lDhdt ) 	
	!! Consolidate and adjust the timestep
	call mpi_allreduce(timeStep, work, 1, dp_mpi, mpi_min, mpi_comm_world, ierr)
	timeStep = work
	timeStep = max( timeStep, pTimeStepMin )
	timeStep = min( timeStep, pTimeStepMax )
	if ( (time+timeStep)>pTimeEnd) timeStep = pTimeEnd-time	
	!! Add ice flow 
	lH = lH+lDhdt*timeStep
	!! Add snow
	lSnow = lSnow*timeStep ! m_ice/yr -> m_ice
	lH = lH+lSnow
	!! Remove melt
	lMelt = lMelt*timeStep ! m_ice/yr -> m_ice
	where (lMelt>lH) lMelt = lH ! limit balance so lH>=0 (physically correct)
	lH = lH-lMelt	
	!! Share first row upwards with prev proc
	call mpi_isend(lH(1,jSta), lNx, dp_mpi, prev, 12, mpi_comm_world, request2(1), ierr)
        if (next .ne. mpi_proc_null) &
	        call mpi_irecv(lH(1,jEnd+1), lNx, dp_mpi, next, 12, mpi_comm_world, request2(2), ierr)
	call mpi_waitall(2, request2, status2, ierr)
	
	! Accumulate rain and melt water	
	lRain = lRain*timeStep ! m_water/yr -> m_water	
	lWater = lWater+lRain+lMelt*(pRhoIce/pRhoWater)
	!! Edges are not used, set to 0
	lWater(1,:) = 0._dp; lWater(lNx,:) = 0._dp; lWater(:,1) = 0._dp; lWater(:,lNy) = 0._dp
	
	! Track ice sources/sinks
	if (pDoTrackVol) &
		call trackIceVol( dvolSrc, dvolSnk, proc, numProc-1, jSta, jEnd, lNx, lNy, lDx, lDy, qx, &
			qy, lSnow, lMelt, timeStep)
	
	! Advance to next step
	time = time+timeStep
	step = step+1
	
end do

! Gather variables
call mpi_allgatherv (lH(1,jSta), jjlen(proc), dp_mpi, lH, jjlen, idisp, dp_mpi, mpi_comm_world, ierr)	
call mpi_allgatherv (lTempS(1,jSta), jjlen(proc), dp_mpi, lTempS, jjlen, idisp, dp_mpi, mpi_comm_world, ierr)	
call mpi_allgatherv (lSnow(1,jSta), jjlen(proc), dp_mpi, lSnow, jjlen, idisp, dp_mpi, mpi_comm_world, ierr)
call mpi_allgatherv (lMelt(1,jSta), jjlen(proc), dp_mpi, lMelt, jjlen, idisp, dp_mpi, mpi_comm_world, ierr)	
call mpi_allgatherv (lWater(1,jSta), jjlen(proc), dp_mpi, lWater, jjlen, idisp, dp_mpi, mpi_comm_world, ierr)	
if (pDoTemp) then
	call mpi_allgatherv (lTempB(1,jSta), jjlen(proc), dp_mpi, lTempB, jjlen, idisp, dp_mpi, mpi_comm_world, ierr)	
	call mpi_allgatherv (lTempM(1,jSta), jjlen(proc), dp_mpi, lTempM, jjlen, idisp, dp_mpi, mpi_comm_world, ierr)
end if
if (pDoTrackVol) then
	call mpi_reduce(dvolSrc,work,1,dp_mpi,mpi_sum,0,mpi_comm_world,ierr)
	if (proc==0) dvolSrc = work
	call mpi_reduce(dvolSnk,work,1,dp_mpi,mpi_sum,0,mpi_comm_world,ierr)
	if (proc==0) dvolSnk = work
	dvol = sum(lH(2:lNx-1,2:lNy-1))*lDx*lDy - initVol
end if	

! Compute average timestep
timeStepMean = (pTimeEnd-pTimeStart)/step

!! DEBUG: test for water conservation, this test works only at ss with no flux bnds
!print*,'rain+melt, precip:', sum(lWater)*lDx*lDy, pPrecipRate*(lNx-2)*(lNy-2)*lDx*lDy 
!! END DEBUG

! Convert total rain + melt to an effective precipitation rate
lWater = lWater/(pTimeEnd-pTimeStart)

! Update ice surface topography
call applyBc( pBcN, pBcS, pBcE, pBcW, lH, lT, jSta, jEnd, proc, numProc-1 ) 
where (lH>0._dp)
	lHT = lH+lT
elsewhere
	lHT = lT
end where

! Compute velocities 
call velocity ( lDx, lDy, pC, pCs, lH, lHT, lT, pGamma, lUDefm, lVDefm, lUSlid, lVSlid, lSliding, &
	lConstrict, pDoTemp, lTempM, lTempB, dtdxx, dtdxy, dtdyy )

! Low-res -> high-res ice thickness, surface topography, sliding velocity magnitude, water
if ((lNx/=fNx).or.(lNy/=fNy)) then
	call lowToHighRes ( lX, fX, lY, fY, lDx, lDy, lH, fH )
	call lowToHighRes ( lX, fX, lY, fY, lDx, lDy, lHT, fHT )	  
	call lowToHighRes ( lX, fX, lY, fY, lDx, lDy, lSliding, fSliding )
	call lowToHighRes ( lX, fX, lY, fY, lDx, lDy, lWater, fWater )
	!! Treat special cases
	!!! Zero ice thickness	
	where (fH<dp_eps)
		fH = 0._dp 
		fHT = fT 
		fSliding = 0._dp ! no erosion without ice
	end where
	!!! Treat high-res peaks above low-res ice as  nunataks
	!!! NOTE: not clear whether this is desirable behavior
	where (fHT<fT) 
		fH = 0._dp 
		fSliding = 0._dp 
	end where
else
	fH = lH
	fHT = lHT
	fSliding = lSliding
	fWater = lWater
end if

! Logical mask for icy points
where (fH<dp_eps) 
	fIceFree = .true. ! flag ice-free nodes
elsewhere
	fIceFree = .false.
end where

! Glacial erosion rate
where (fIceFree .eqv. .false.)
	fErosRate = erosFact*fSliding 
	fErosRate = min(fErosRate,erosRateCeil) 
elsewhere
	fErosRate = 0._dp
end where

! Compute balance rate for output
lBalRate = (lSnow-lMelt)/timeStep 

! Clean up
deallocate( idisp, jjlen, qx, qy, lRain, lSnow, lMelt, dtdxx, dtdyy, dtdxy, lDhdt )

return
end subroutine runIce

! ==================================================================================================
! applyBc: apply the specified n,s,e,w boundary conditions
! ==================================================================================================
subroutine applyBc ( pBcN, pBcS, pBcE, pBcW, lH, lT, j0, j1, proc, lastProc )

! Arguments:
!! pBcN, pBcS, pBcE, pBcW (in) = N, S, E, W boundary condition flags. 
!!! 0->ice-free
!!! 1-> no-flux 
!!! 2-> scaled thickness
!!! 3-> cyclic
!!! 4-> reflect
!! lH (inout) = ice thickness grid
!! lT (inout) = topography grid
!! j0, j1 (in) = the range of rows to be computed by this thread in parallel
!! proc (in) = integer identifier for this thread
!! lastProc (in) = integer identifier for the last thread (0 is the first, numProc-1 is the last)

! Notes:
!! Tested & working 5/2/2014, Keith Ma

integer, intent(in) :: pBcN, pBcS, pBcE, pBcW, j0, j1, proc, lastProc
real(dp), intent(inout) :: lH(:,:), lT(:,:)

integer :: nx, ny, ierr, request4(4), status4(mpi_status_size,4)

real(dp), parameter :: bndfrac = 0.5_dp ! (Option 2) bnd ice thickness as frac of adjacent interior pt

! Get grid dimensions
nx = size(lT,1)
ny = size(lT,2)

! Ice free BCs
if (pBcN==0 .and. proc==lastProc) then
	lT(:,ny) = lT(:,ny-1)
	lH(:,ny) = 0._dp
end if
if (pBcS==0) then
	lT(:,1) = lT(:,2)
	lH(:,1) = 0._dp
end if
if (pBcE==0) then
	lT(nx,j0:j1) = lT(nx-1,j0:j1)
	lH(nx,j0:j1) = 0._dp
end if
if (pBcW==0) then
	lT(1,j0:j1) = lT(2,j0:j1)
	lH(1,j0:j1) = 0._dp
end if

! No-flux BCs
if (pBcN==1 .and. proc==lastProc) then
	lT(:,ny) = lT(:,ny-1)
	lH(:,ny) = lH(:,ny-1)
end if
if (pBcS==1) then
	lT(:,1) = lT(:,2)
	lH(:,1) = lH(:,2)
end if
if (pBcE==1) then
	lT(nx,j0:j1) = lT(nx-1,j0:j1)
	lH(nx,j0:j1) = lH(nx-1,j0:j1)
end if
if (pBcW==1) then
	lT(1,j0:j1) = lT(2,j0:j1)
	lH(1,j0:j1) = lH(2,j0:j1)
end if

! Scaled ice thickness BCs
if (pBcN==2 .and. proc==lastProc) then
	lT(:,ny) = lT(:,ny-1)
	lH(:,ny) = lH(:,ny-1)*bndfrac
end if
if (pBcS==2) then
	lT(:,1) = lT(:,2)
	lH(:,1) = lH(:,2)*bndfrac
end if
if (pBcE==2) then
	lT(nx,j0:j1) = lT(nx-1,j0:j1)
	lH(nx,j0:j1) = lH(nx-1,j0:j1)*bndfrac
end if
if (pBcW==2) then
	lT(1,j0:j1) = lT(2,j0:j1)
	lH(1,j0:j1) = lH(2,j0:j1)*bndfrac
end if

! Cyclic BCs
if ((pBcN==3 .and. pBcS==3)  .and. (proc==0 .or. proc==lastProc)) then
	!! Parallel communications: Send the 1st interior row from the 1st thread to the last thread, 
	!!! and send the last interior row from the last thread to the 1st thread.
	if (proc==0) then 
		call mpi_isend( lT(1,2), nx, dp_mpi, lastProc, 1, mpi_comm_world, request4(1), ierr )
		call mpi_isend( lH(1,2), nx, dp_mpi, lastProc, 2, mpi_comm_world, request4(2), ierr )
		call mpi_irecv( lT(1,ny-1), nx, dp_mpi, lastProc, 3, mpi_comm_world, request4(3), ierr )
		call mpi_irecv( lH(1,ny-1), nx, dp_mpi, lastProc, 4, mpi_comm_world, request4(4), ierr )
		call mpi_waitall( 4, request4, status4, ierr)	
	else if (proc==lastProc) then
		call mpi_isend( lT(1,ny-1), nx, dp_mpi, 0, 3, mpi_comm_world, request4(1), ierr )
		call mpi_isend( lH(1,ny-1), nx, dp_mpi, 0, 4, mpi_comm_world, request4(2), ierr )
		call mpi_irecv( lT(1,2), nx, dp_mpi, 0, 1, mpi_comm_world, request4(3), ierr )
		call mpi_irecv( lH(1,2), nx, dp_mpi, 0, 2, mpi_comm_world, request4(4), ierr )
		call mpi_waitall( 4, request4, status4, ierr)		
	end if
	!! Normal steps
	lT(:,ny) = lT(:,2)
	lT(:,1) = lT(:,ny-1)
	lH(:,ny) = lH(:,2)
	lH(:,1) = lH(:,ny-1)
end if
if (pBcE==3 .and. pBcW==3) then
	lT(nx,j0:j1) = lT(2,j0:j1)
	lH(nx,j0:j1) = lH(2,j0:j1)
	lT(1,j0:j1) = lT(nx-1,j0:j1)
	lH(1,j0:j1) = lH(nx-1,j0:j1)
end if

! Reflected BCs
if (pBcN==4 .and. proc==lastProc) then
	lT(:,ny) = lT(:,ny-2)
	lH(:,ny) = lH(:,ny-2)
end if
if (pBcS==4) then
	lT(:,1) = lT(:,3)
	lH(:,1) = lH(:,3)
end if
if (pBcE==4) then
	lT(nx,j0:j1) = lT(nx-2,j0:j1)
	lH(nx,j0:j1) = lH(nx-2,j0:j1)
end if
if (pBcW==4) then
	lT(1,j0:j1) = lT(3,j0:j1)
	lH(1,j0:j1) = lH(3,j0:j1)
end if

return
end subroutine applyBc

! ==================================================================================================
! balanceRate: Compute ice & water balance using a positive-degree-day scheme
! ==================================================================================================
subroutine balanceRate( jSta, jEnd, pRhoIce, pRhoWater, pPrecipRate, pTempYrRng, pMeltFact, &
	lTempS, lRainRate, lSnowRate, lMeltRate )
	
! About: The positive-degree-day scheme, based on Kessler et al 2006, JGR and references therein,
!! provides a balance rate that depends on precip and temperature, and allows the model to conserve
!! water. This implementation assumes a sinusoidal annual temperature cycle centered on the mean annual surface 
!! temperature. The snowfall fraction is computed from the fraction of the year when the surface 
!! temperature is <=0 C. Ice melting varys linearly with the annual positive-degree-days (the 
!! integral of the positive part of the yearly temperature cycle. 	

! Arguments:
!! jSta, jEnd (in) =  indices of the rows handled by this thread
!! lDx, lDy (in) = low-res grid spacing, m
!! pRhoIce, pRhoWater (in) = ice, water density, kg/m^3
!! pPrecipRate (in) = spatially uniform precipitation rate, m/yr
!! pTempYrRng (in) = amplitude of the yearly temperature cycle, C
!! pMeltFact (in) = positive-degree-day melting rate constant
!! lTempS (out) = surface temperature grid, C
!! lRainRate (out) = rainfall rate, m_water/yr
!! lSnowRate (out) = snowfall rate, m_ice/yr
!! lMeltRate (out) = ice melting rate, m_ice/yr

! Notes:
!! The current version computes positive degree days at each point, which requires a fairly large
!! number of computations. A more efficient implementation would be to compute a snowfall-elevation
!! curve and a melt-elevation curve and interpolate from these to get the value at each point. This 
!! should be done sometime soon.

integer, intent(in) :: jSta, jEnd
real(dp), intent(in) :: pMeltFact, pTempYrRng, pPrecipRate, lTempS(:,:), pRhoIce, pRhoWater
real(dp), intent(out) :: lRainRate(:,:), lSnowRate(:,:), lMeltRate(:,:)

integer :: i, j, j0, j1, lNx, lNy
real(dp) :: pdd, fs, invTempYrRng, invPi, twot, waterToIce

real(dp), parameter :: cliff_xm = 20000._dp 
real(dp), parameter :: cliff_mdot0 = 2._dp
real(dp), parameter :: cliff_n = 3._dp

! Get grid dimensions
lNx = size(lSnowRate,1)
lNy = size(lSnowRate,2)

! Initialize to zero
lMeltRate = 0._dp
lRainRate = 0._dp
lSnowRate = 0._dp

! Interior points only
j0 = max(2,jSta); j1 = min(lNy-1,jEnd) 

! A few constants to save on computations
invTempYrRng = 1/pTempYrRng
invPi = 1/pi
waterToIce = pRhoWater/pRhoIce

do j = j0,j1
	do i = 2,lNx-1
		
		if (lTempS(i,j)>=pTempYrRng) then ! temperatures are uniformly positive throughout the year
			pdd = dayInYr*lTempS(i,j) ! positive degree days
			fs = 0._dp ! fraction snowfall
			
		elseif (lTempS(i,j)<=-pTempYrRng) then ! temperatures are uniformly negative throughout the year
			pdd = 0._dp
			fs = 1._dp
		
		else ! temperature sign depends on the season				
			!!...original, slow
			!lT = asin(-lTempS(i,j)/pTempYrRng)/2/pi
			!pdd = dayInYr*( lTempS(i,j)*(0.5-2*lT) + pTempYrRng/pi*cos(2*pi*lT) )
			!fs = 0.5 + 2*lT				
			!...slightly faster (~10%)
			twot = asin(-lTempS(i,j)*invTempYrRng)*invPi
			pdd = dayInYr*( lTempS(i,j)*(0.5_dp-twot) + pTempYrRng*invPi*cos(pi*twot) )
			fs = 0.5_dp + twot
			
		endif
		
		lRainRate(i,j) = (1-fs)*pPrecipRate ! m_water / yr
		lSnowRate(i,j) = fs*pPrecipRate*waterToIce ! m_ice / yr
		lMeltRate(i,j) = pMeltFact*pdd ! m_ice / yr
		
	end do 
end do

return
end subroutine balanceRate

! ==================================================================================================
! basalTemp: Compute temperatures at the glacier bed
! ==================================================================================================
subroutine basalTemp ( jSta, jEnd, pTempBasalGrad, pTempDiffuse, lTempS, lBalRate, lH, lTempB )

integer, intent(in) :: jSta, jEnd
real(dp), intent(in) :: pTempBasalGrad, pTempDiffuse, lTempS(:,:), lBalRate(:,:), lH(:,:)
real(dp), intent(out) :: lTempB(:,:)

integer :: i, j, lNx, lNy, j0, j1
real(dp), allocatable :: work(:,:)

! About: Uses a crude steady-state assumption and should be turned on only with great caution. 
!! Calculations are based on Siegert & Dowdeswell 1995, Numerical modeling of the late Weichselian 
!! Svalbard-Barents Sea ice sheet, Quaternary Research, which in turn is based on Robin 1955, Ice 
!! Movement and Temperature Distribution in Glaciers and Ice Sheets, Journal of Glaciology. Assumes 
!! steady state and no horizontal advection. Significantly (>5 deg C!) underpredicts basal 
!! temperatures for the EISMINT 1 fixed margin test case

! Arguments:
!! jSta, jEnd (in) =  indices of the rows handled by this thread
!! pTempBasalGrad (in) = temperature gradient at the glacier bed, C/m
!! pTempDiffuse (in) = thermal diffusivity, m^2/s
!! lTempS (in) = surface temperature grid, C
!! lBalRate (in) = balance rate, m_ice/yr
!! lH (in) = ice thickness grid, m
!! lTempB (out) = basal temperature, C

! Get grid dimensions
lNx = size(lH,1)
lNy = size(lH,2)
allocate( work(lNx,lNy) )

! Interior points only
j0 = max(2,jSta); j1 = min(lNy-1,jEnd) 

do j = j0,j1
	do i = 2,lNx-1	
		lTempB(i,j) = lTempS(i,j) ! initial value
		work(i,j) = 0._dp
		if (lH(i,j)>0._dp) lTempB(i,j) = lTempS(i,j)+pTempBasalGrad*lH(i,j) ! simple gradient if lBalRate<=0
		if (lBalRate(i,j) > 0._dp .and. lH(i,j) > 0._dp) work(i,j) = 2._dp*lH(i,j)*pTempDiffuse/lBalRate(i,j)*secInYr
		if (work(i,j)>0._dp) work(i,j) = sqrt(work(i,j))
		if (lH(i,j)>0._dp .and. work(i,j)>0._dp) &
			lTempB(i,j) = lTempS(i,j)+pTempBasalGrad*work(i,j)*(sqrt(3.1415_dp)/2._dp)*erf(lH(i,j)/work(i,j))	
	end do 
end do

deallocate( work )

return
end subroutine basalTemp

! ==================================================================================================
! highToLowRes: linear interpolation of high-res data onto low-res grid
! ==================================================================================================
subroutine highToLowRes ( lX, fX, lY, fY, fDx, fDy, lVar, fVar ) 

! Arguments:
!! lX, lY (in) = low-res coordinate grids
!! fX, fY (in) = high-res coordinate grids
!! fDx, fDy (in) = high-res grid spacing
!! lVar (out) = low-res variable grid
!! fVar (in) = low-res variable grid

! Note: if the high and low-res grids are equivalent (excluding the low-res bc points), just copy
! Note: high-res data is smoothed to avoid aliasing

real(dp), intent(in) :: lX(:,:), fX(:,:), lY(:,:), fY(:,:), fVar(:,:), fDx, fDy
real(dp), intent(out) :: lVar(:,:)

integer :: i, j, ii, jj, lNx, lNy, fNx, fNy
real(dp) :: xu, xt
real(dp), allocatable :: fVarSmooth(:,:)

! Get grid dimensions
lNx = size(lVar,1)
lNy = size(lVar,2)
fNx = size(fVar,1)
fNy = size(fVar,2)

! Equivalent grids, copy
if ((fNx==lNx-2).and.(fNy==lNy-2)) then
	lVar(2:lNx-1,2:lNy-1) = fVar
	
! Distinct grids, interpolate
else 

	! Smooth the high-res grid to avoid aliasing
	allocate( fVarSmooth(fNx,fNy) )
	fVarSmooth = fVar
	call smoothGrid( fVarSmooth )
	
	! Interpolate
	do j = 1,lNy
		do i = 1,lNx
			ii = int(lX(i,j)/fDx)+1
			jj = int(lY(i,j)/fDy)+1
			!! Low-res point lies outside the high-res domain (boundary points)		
			if (ii<1 .or. ii>fNx .or. jj<1 .or. jj>fNy) then
				lVar(i,j) = 0._dp
			!! Low-res point is on the edge of the high res grid
			else if (ii==fNx .or. jj==fNy) then
				lVar(i,j) = fVarSmooth(ii,jj)
			!! Normal interior point
			else 
				xu = (lX(i,j)-fX(ii,jj))/fDx 
				xt = (lY(i,j)-fY(ii,jj))/fDy 
				lVar(i,j) = (1._dp-xu)*(1._dp-xt)*fVarSmooth(ii,jj) + (1._dp-xu)*xt*fVarSmooth(ii,jj+1) &
					+ xu*xt*fVarSmooth(ii+1,jj+1) + xu*(1._dp-xt)*fVarSmooth(ii+1,jj)	
			endif		
		enddo
	enddo

	deallocate( fVarSmooth )

end if	


return
end subroutine highToLowRes

! ==================================================================================================
! lowToHighRes: linear interpolation of low-res data onto high-res grid
! ==================================================================================================
subroutine lowToHighRes ( lX, fX, lY, fY, lDx, lDy, lVar, fVar ) 

! Arguments:
!! lX, lY (in) = low-res coordinate grids
!! fX, fY (in) = high-res coordinate grids
!! lDx, lDy (in) = low-res grid spacing
!! lVar (in) = low-res variable grid
!! fVar (out) = low-res variable grid

real(dp), intent(in) :: lX(:,:), fX(:,:), lY(:,:), fY(:,:), lVar(:,:), lDx, lDy
real(dp), intent(out) :: fVar(:,:)

integer :: i, j, ii, jj, lNx, lNy, fNx, fNy
real(dp) :: xu, xt

! Get grid dimensions
lNx = size(lVar,1)
lNy = size(lVar,2)
fNx = size(fVar,1)
fNy = size(fVar,2)

! Equivalent grids, copy
if ((fNx==lNx-2).and.(fNy==lNy-2)) then
	fVar = lVar(2:lNx-1,2:lNy-1)
	
! Distinct grids, interpolate
else 
	do j=1,fNy
		do i=1,fNx	
			ii = int(fX(i,j)/lDx)+2
			jj = int(fY(i,j)/lDy)+2		
			xu = (fX(i,j)-lX(ii,jj))/lDx  
			xt = (fY(i,j)-lY(ii,jj))/lDy  		
			if (ii==lNx) then ! xu==0, lVar(ii+1, ) is not used and does not exist
				fVar(i,j) = (1._dp-xt)*lVar(ii,jj) + xt*lVar(ii,jj+1) 		
			else if (jj==lNy) then ! xt==0, lVar( , jj+1) is not used and does not exist
				fVar(i,j) = (1._dp-xu)*lVar(ii,jj) + xu*lVar(ii+1,jj)		
			else
				fVar(i,j) = (1._dp-xu)*(1._dp-xt)*lVar(ii,jj) + xt*(1._dp-xu)*lVar(ii,jj+1) + &
					xu*xt*lVar(ii+1,jj+1) + (1._dp-xt)*xu*lVar(ii+1,jj)		
			end if				
		enddo
	enddo
end if	

return
end subroutine lowToHighRes

! ==================================================================================================
! meltingTemp: Compute the pressure melting point at the base of the glacier
! ==================================================================================================
subroutine meltingTemp ( jSta, jEnd, lNx, lNy, lH, lTempM )

! Arguments:
!! jSta, jEnd (in) =  indices of the rows handled by this thread
!! lNx, lNy (in) = low-res grid dimensions
!! lH (in) = low-res ice thickness grid, m
!! lTempM (out) = melting temperature at the glacier bed, C

integer, intent(in) :: jSta, jEnd
real(dp), intent(in) :: lH(:,:)
real(dp), intent(out) :: lTempM(:,:)

integer :: i, j, lNx, lNy, j0, j1

! Get grid dimensions
lNx = size(lH,1)
lNy = size(lH,2)

! Interior points only
j0 = max(2,jSta); j1 = min(lNy-1,jEnd) 
do j = j0,j1
	do i = 2,lNx-1				
		if (lH(i,j)>0._dp) then
			lTempM(i,j) = -8.7e-4_dp*lH(i,j) 
		else
			lTempM(i,j) = 0._dp
		endif				
	end do 
end do

return
end subroutine meltingTemp

! ==================================================================================================
! paraRange: Divide up array row-by-row for parallel processing
! ==================================================================================================
subroutine paraRange(n1, n2, nprocs, irank, ista, iend)

! Arguments:
!! n1, n2 (in) = grid dimensions in the 1- and 2-directions
!! nprocs (in) = total number of threads
!! irank (in) = integer label for this thread
!! ista, iend (out) = first and last row to be processed by this thread

integer, intent(in) :: n1, n2, nprocs, irank
integer, intent(out) :: ista, iend

integer :: iwork1, iwork2

iwork1 = (n2 - n1 + 1) / nprocs
iwork2 = mod(n2 - n1 + 1, nprocs)
ista = irank * iwork1 + n1 + min(irank, iwork2)
iend = ista + iwork1 - 1
if (iwork2 > irank) iend = iend + 1

return
end subroutine paraRange

! ==================================================================================================
! surfaceTemp: Compute surface temperatures using a simple lapse rate 
! ==================================================================================================
subroutine surfaceTemp ( jSta, jEnd, time, pTempSlMin, pTempSlMax, pTempPeriod, pTempLapse, lHT, &
	lTempS, tempSl )	
	
! Arguments:
!! jSta, jEnd (in) =  indices of the rows handled by this thread
!! time (in) = current model time, yr
!! pTempSlMax, pTempSlMin (in) = Maximum and minimum sea-level temperature over a sinusoidal climate cycle
!! pTempPeriod (in) = Duration of one full sinusoidal climate cycle, yr
!! pTempLapse (in) = Temperature lapse rate, C/m
!! lHT (in) = ice surface topography grid, m
!! lTempS (out) = surface temperature grid, C
!! lDx, lDy (in) = low-res grid spacing, m
!! tempSl (out) = sea-level temperature. C
			
integer, intent(in) :: jSta, jEnd
real(dp), intent(in) :: time, pTempSlMin, pTempSlMax, pTempPeriod, pTempLapse, lHT(:,:)
real(dp), intent(out) :: lTempS(:,:), tempSl

integer :: i, j, j0, j1, lNx, lNy
real(dp) :: tempRng

! Get grid dimensions
lNx = size(lHT,1)
lNy = size(lHT,2)

! Mean sea-level temperature (sinusoidal cycle)
tempRng = pTempSlMax-pTempSlMin
tempSl = pTempSlMin+tempRng*(sin(2._dp*pi*time/pTempPeriod-pi/2._dp)+1._dp)/2._dp 

! Surface temperature
j0 = max(2,jSta); j1 = min(lNy-1,jEnd) ! interior points in proc range only
do j = j0,j1
	do i = 2,lNx-1
		lTempS(i,j) = tempSl-pTempLapse*lHT(i,j)
	end do 
end do

return
end subroutine surfaceTemp

! ==================================================================================================
! updateHeight: Computes ice thickness change due to deformation and sliding
! ==================================================================================================
subroutine updateHeight ( jSta, jEnd, next, prev, pDoTemp, pC, pCs, lDx, lDy, lT, lH, lHT, &
	lTempB, lTempM, timeStep, qx, qy, dtdxx, dtdyy, dtdxy, pGamma, lDhdt )
	
! About: The discretization is "Method 1" from Hindmarsh & Payne 1996, Ann. Glaciology. Ice flux is 
!! limited to conserve mass using a method modified from Wang et al 2011, Computers & Fluids.	

! Arguments:
!! jSta, jEnd (in): indices of the rows handled by this thread
!! next, prev (in) = integer labels for the next and previous threads
!! pDoTemp (in) = flag for polythermal ice 
!! pC (in) = ice deformation constant
!! pCs (in) = ice sliding constant
!! lDx, lDy (in) = low-res grid spacing, m
!! lT (in) = topography grid, m
!! lH (in) = ice thickness grid, m
!! lHT (in) = ice surface topography grid, m
!! lTempB (in) = temperature at the glacier bed, C
!! lTempM (in) = ice melting temp at the glacier bed, C
!! timeStep (out) = ice model timestep, yr
!! qx, qy (out) = ice flux in the x- and y-directions, computed on a staggered grid
!! dtdxx, dtdxy, dtdyy (in) = 2nd spatial derivatives of the bedrock
!! pGamma (in) = constriction parameter
!! lDhdt (out) = ice thickness rate of change, due to ice flow (defm & sliding), m/yr

logical, intent(in) :: pDoTemp
integer, intent(in) :: jSta, jEnd, next, prev
real(dp), intent(in) :: pC, pCs, lDx, lDy, lT(:,:), lHT(:,:), lH(:,:), lTempB(:,:), lTempM(:,:), &
	dtdxx(:,:), dtdyy(:,:), dtdxy(:,:), pGamma
real(dp), intent(out) :: qx(:,:), qy(:,:), timeStep, lDhdt(:,:)

logical :: slide
integer :: i, j, j0, j1, lNx, lNy, request2(2), status2(mpi_status_size,2), ierr, imax
real(dp) :: tHat, hBar, dsdx, dsdy, tempBBar, tempMBar, slopeMagSqr, dtdpp, constr, htMax, htMin, &
	hLocal(4), htLocal(4), hmax
real(dp), allocatable :: d(:,:)

! Get grid dimensions
lNx = size(lH,1)
lNy = size(lH,2)

! ----------------------
! Effective diffusivity 

j0 = jSta; 
j1 = min(lNy-1, jEnd)
allocate( d(lNx-1,lNy-1) )
slide = .true. ! default is always sliding, only changed if pDoTemp==.true.

do j=j0,j1
	do i=1,lNx-1
	
		!! Flux limited, after Wang et al 2011, Computers & Fluids
		tHat = max( lT(i,j), lT(i+1,j), lT(i,j+1), lT(i+1,j+1) )
		
		hBar = ( max(0._dp,lHT(i,j)-tHat) + max(0._dp,lHT(i+1,j)-tHat) + &
			max(0._dp,lHT(i,j+1)-tHat) + max(0._dp,lHT(i+1,j+1)-tHat) )/4._dp 
				
		dsdx = ( max(tHat,lHT(i+1,j))-max(tHat,lHT(i,j)) + &
			max(tHat,lHT(i+1,j+1))-max(tHat,lHT(i,j+1)) )/(2._dp*lDx)
		
		dsdy = ( max(tHat,lHT(i,j+1))-max(tHat,lHT(i,j)) + &
			max(tHat,lHT(i+1,j+1))-max(tHat,lHT(i+1,j)) )/(2._dp*lDy)
				
		slopeMagSqr = dsdx**2+dsdy**2 ! useful constant

		! Flux limited, TEST flat-slab bedrock limiter
!		hLocal = [lH(i,j), lH(i+1,j), lH(i,j+1), lH(i+1,j+1)]
!		htLocal = [lHT(i,j), lHT(i+1,j), lHT(i,j+1), lHT(i+1,j+1)]
!		imax = maxloc(htLocal,1)
!		hmax = hLocal(imax)
		
!		hBar = ( min(hmax,lH(i,j))+min(hmax,lH(i+1,j))+min(hmax,lH(i,j+1))+min(hmax,lH(i+1,j+1)) )/4._dp 
				
!		dsdx = ( lHT(i+1,j)-lHT(i,j) + lHT(i+1,j+1)-lHT(i,j+1) )/(2._dp*lDx)
		
!		dsdy = ( lHT(i,j+1)-lHT(i,j) + lHT(i+1,j+1)-lHT(i+1,j) )/(2._dp*lDy)
				
!		slopeMagSqr = dsdx**2+dsdy**2 ! useful constant

			
		!! Constriction factor, using pre-computed topography curvature
		if (slopeMagSqr>dp_eps) then		
			dtdpp = ( dsdy**2*dtdxx(i,j) - 2._dp*dsdx*dsdy*dtdxy(i,j) + dsdx**2*dtdyy(i,j) )/slopeMagSqr
			dtdpp = max(dtdpp,0._dp) ! constriction only retards flow
			constr = 1._dp/(1._dp+pGamma*dtdpp) 
		else
			constr = 1._dp
		end if
							
		!! Determine sliding based on bed temp, if enabled
		if (pDoTemp) then 			
			tempBBar = ( lTempB(i,j)+lTempB(i+1,j)+lTempB(i,j+1)+lTempB(i+1,j+1) )/4._dp
			tempMBar = ( lTempM(i,j)+lTempM(i+1,j)+lTempM(i,j+1)+lTempM(i+1,j+1) )/4._dp
			if (tempBBar>=tempMBar) then
				slide = .true.
			else
				slide = .false.
			end if			
		end if
						
		!! Compute effective diffusivity, and apply the constriction factor
		if (slide) then
			d(i,j) = (pC*hBar+pCs)*hBar**4._dp*slopeMagSqr*constr
		else 
			d(i,j) = pC*hBar**5._dp*slopeMagSqr*constr
		end if
			
	end do
end do 
!! Share last row downwards with next proc
call mpi_isend(d(1,j1), lNx-1, dp_mpi, next, 1, mpi_comm_world, request2(1), ierr)
if (next .ne. mpi_proc_null) &
        call mpi_irecv(d(1,j0-1), lNx-1, dp_mpi, prev, 1, mpi_comm_world, request2(2), ierr)
call mpi_waitall(2, request2, status2, ierr)

! Compute the maximum stable timestep 
!! After Hindmarsh 2001, in Continuum Mechanics and Applications in Geophysics and the Environment. 
!! Experience shows this value is conservative.
if ( maxval(d(:,j0:j1)) > 0) then
        timeStep = (lDx*lDy)/(8._dp*maxval(d(:,j0:j1)))
        print*,"Step:",maxval(d(:,j0:j1)), timeStep
else 
        timeStep = ieee_value(timeStep,  ieee_positive_inf)
end if
        
! --------------
! Ice flux 

! X-direction, with flux limited a la Wang et al 2011, Computers & Fluids
j0 = max(1,jSta-1) 
j1 = min(lNy-2,jEnd-1)
do j=j0,j1
	do i=1,lNx-1	
		tHat = max( lT(i+1,j+1), lT(i,j+1) )
		qx(i,j) = -(d(i,j)+d(i,j+1))/2._dp * ( max(tHat,lHT(i+1,j+1))-max(tHat,lHT(i,j+1)) )/lDx	
	end do
end do

! Y-Direction, with flux limited a la Wang et al 2011, Computers & Fluids
j0 = jSta 
j1 = min(lNy-1,jEnd) 
do j = j0,j1
	do i = 1,lNx-2
		tHat = max( lT(i+1,j+1), lT(i+1,j) )
		qy(i,j) = -( d(i,j)+d(i+1,j) )/2._dp * ( max(tHat,lHT(i+1,j+1))-max(tHat,lHT(i+1,j)) )/lDy	
	end do
end do
!! share last row downwards with next proc
call mpi_isend(qy(1,j1), lNx-2, dp_mpi, next, 1, mpi_comm_world, request2(1), ierr)
if (next .ne. mpi_proc_null) &
        call mpi_irecv(qy(1,j0-1), lNx-2, dp_mpi, prev, 1, mpi_comm_world, request2(2), ierr)
call mpi_waitall(2, request2, status2, ierr)
		
! -----------------
! Ice thickness
j0 = max(2,jSta); ! interior points only
j1 = min(lNy-1,jEnd) 		
do j=j0,j1
	do i=2,lNx-1
		lDhdt(i,j) = -( qx(i,j-1)-qx(i-1,j-1) )/lDx - ( qy(i-1,j)-qy(i-1,j-1) )/lDy
	end do
end do

deallocate( d )

end subroutine updateHeight

! ==================================================================================================
! velocity: Compute deformation and sliding velocity
! ==================================================================================================
subroutine velocity ( lDx, lDy, pC, pCs, lH, lHT, lT, pGamma, lUDefm, lVDefm, lUSlid, lVSlid, &
	lSliding, lConstrict, pDoTemp, lTempM, lTempB, dtdxx, dtdxy, dtdyy )

! Arguments:
!! lDx, lDy (in) = low-res grid spacing, m
!! pC (in) = ice deformation constant
!! pCs (in) = ice sliding constant
!! lH (in) = ice thickness grid, m
!! lHT (in) = ice surface topography grid, m
!! lT (in) = topography grid, m
!! pGamma (in) = constriction parameter
!! lUDefm, lVDefm (out) = ice deformation velocity vector
!! lUSlid, lVSlid (out) = ice sliding velocity vector
!! lSliding (out) = ice sliding velocity magnitude
!! lConstrict (out) = constriction factor
!! pDoTemp (in) = flag for polythermal ice 
!! lTempM (in) = ice melting temp at the glacier bed, C
!! lTempB (in) = temperature at the glacier bed, C
!! dtdxx, dtdxy, dtdyy (in) = 2nd spatial derivatives of the bedrock

logical, intent(in) :: pDoTemp
real(dp), intent(in) :: lH(:,:), lHT(:,:), lT(:,:), lDy, lDx, pC, pCs, pGamma, lTempB(:,:), &
	lTempM(:,:), dtdxx(:,:), dtdxy(:,:), dtdyy(:,:)
real(dp), intent(out) :: lUDefm(:,:), lVDefm(:,:), lUSlid(:,:), lVSlid(:,:), lSliding(:,:), &
	lConstrict(:,:)

logical :: slide
integer :: i, j, lNx, lNy
real(dp) :: tHat, hBar, dsdx, dsdy, tempBBar, tempMBar, slopeMagSqr, dtdpp
real(dp), allocatable :: lUDefmB(:,:), lVDefmB(:,:), lUSlidB(:,:), lVSlidB(:,:), lConstrictB(:,:)

! Get grid dimensions
lNx = size(lH,1)
lNy = size(lH,2)

! Allocate local grids
allocate ( lUDefmB(lNx-1,lNy-1), lVDefmB(lNx-1,lNy-1), lUSlidB(lNx-1,lNy-1), lVSlidB(lNx-1,lNy-1), &
	lConstrictB(lNx-1,lNy-1) )

! Velocity on staggered grid (suffix=B), using flux limiter
do j=1,lNy-1
	do i=1,lNx-1
	
		! Flux limited, after Wang et al 2011, Computers & Fluids
		tHat = max( lT(i,j), lT(i+1,j), lT(i,j+1), lT(i+1,j+1) )
		
		hBar = ( max(0._dp,lHT(i,j)-tHat) + max(0._dp,lHT(i+1,j)-tHat) + &
			max(0._dp,lHT(i,j+1)-tHat) + max(0._dp,lHT(i+1,j+1)-tHat) )/4._dp
		
		dsdx = ( max(tHat,lHT(i+1,j))-max(tHat,lHT(i,j)) + &
			max(tHat,lHT(i+1,j+1))-max(tHat,lHT(i,j+1)) )/(2._dp*lDx)
		
		dsdy = ( max(tHat,lHT(i,j+1))-max(tHat,lHT(i,j)) + &
			max(tHat,lHT(i+1,j+1))-max(tHat,lHT(i+1,j)) )/(2._dp*lDy)
			
		!! Not flux limited -> not reasonable		
		!hBar = ( lH(i,j) + lH(i+1,j) + lH(i,j+1) + lH(i+1,j+1) )/4._dp		
		!dsdx = ( lHT(i+1,j)-lHT(i,j) + lHT(i+1,j+1)-lHT(i,j+1) )/(2._dp*lDx)		
		!dsdy = ( lHT(i,j+1)-lHT(i,j) + lHT(i+1,j+1)-lHT(i+1,j) )/(2._dp*lDy)	
		
		slopeMagSqr = dsdx**2+dsdy**2 ! useful constant
			
		! Constriction factor, using pre-computed topography curvature
		if (slopeMagSqr>dp_eps) then		
			dtdpp = ( dsdy**2*dtdxx(i,j) - 2._dp*dsdx*dsdy*dtdxy(i,j) + dsdx**2*dtdyy(i,j) )/slopeMagSqr
			dtdpp = max(dtdpp,0._dp) ! constriction only retards flow
			lConstrictB(i,j) = 1._dp/(1._dp+pGamma*dtdpp) 
		else
			lConstrictB(i,j) = 1._dp
		end if
											
		! Deformation velocity		
		lUDefmB(i,j) = pC*hBar**4._dp*slopeMagSqr*dsdx*lConstrictB(i,j)
		lVDefmB(i,j) = pC*hBar**4._dp*slopeMagSqr*dsdy*lConstrictB(i,j)
		
		! Determine sliding based on bed temp, if enabled
		slide = .true.
		if (pDoTemp) then 			
			tempBBar = ( lTempB(i,j)+lTempB(i+1,j)+lTempB(i,j+1)+lTempB(i+1,j+1) )/4._dp
			tempMBar = ( lTempM(i,j)+lTempM(i+1,j)+lTempM(i,j+1)+lTempM(i+1,j+1) )/4._dp
			if (tempBBar>=tempMBar) then
				slide = .true.
			else
				slide = .false.
			end if			
		end if		
		if (slide) then
			lUSlidB(i,j) = pCs*hBar**3._dp*slopeMagSqr*dsdx*lConstrictB(i,j)
			lVSlidB(i,j) = pCs*hBar**3._dp*slopeMagSqr*dsdy*lConstrictB(i,j)
		else
			lUSlidB(i,j) = 0._dp
			lVSlidB(i,j) = 0._dp		
		end if
						
	end do
end do 

! Interpolate to the real (non-staggered) grid
do j=2,lNy-1
	do i=2,lNx-1
		lUDefm(i,j) = ( lUDefmB(i-1,j-1)+lUDefmB(i,j-1)+lUDefmB(i,j)+lUDefmB(i-1,j) )/4._dp
		lVDefm(i,j) = ( lVDefmB(i-1,j-1)+lVDefmB(i,j-1)+lVDefmB(i,j)+lVDefmB(i-1,j) )/4._dp
		lUSlid(i,j) = ( lUSlidB(i-1,j-1)+lUSlidB(i,j-1)+lUSlidB(i,j)+lUSlidB(i-1,j) )/4._dp
		lVSlid(i,j) = ( lVSlidB(i-1,j-1)+lVSlidB(i,j-1)+lVSlidB(i,j)+lVSlidB(i-1,j) )/4._dp
		lConstrict(i,j) = ( lConstrictB(i-1,j-1)+lConstrictB(i,j-1)+ &
			lConstrictB(i,j)+lConstrictB(i-1,j) )/4._dp		
		lSliding(i,j) = sqrt(lUSlid(i,j)**2._dp+lVSlid(i,j)**2._dp)
	end do
end do

! deallocate
deallocate ( lUDefmB, lVDefmB, lUSlidB, lVSlidB, lConstrictB)

end subroutine velocity

! ==================================================================================================
! spatial2ndDerivSg: Compute the spatial second derivatives of topography on the staggered grid 
! ==================================================================================================
subroutine spatial2ndDerivSg ( lT, lDx, lDy, dtdxx, dtdxy, dtdyy )

! Arguments: 
!! lT (in) = low-res topography grid
!! lDx, lDy (in) = low-res grid spacing, m
!! lDtxx (out) = d^2(elevation)/dx^2 
!! lDtxy (out) = d^2(elevation)/dxdy 
!! lDtxx (out) = d^2(elevation)/dy^2 

real(dp), intent(in) :: lT(:,:), lDx, lDy
real(dp), intent(out) :: dtdxx(:,:), dtdxy(:,:), dtdyy(:,:) ! size is lNx-1,lNy-1

integer :: lNx, lNy, i, j
real(dp), dimension(:,:), allocatable :: dtdx, dtdy

! Get grid dims
lNx = size(lT,1)
lNy = size(lT,2)
allocate( dtdx(lNx-1,lNy-1), dtdy(lNx-1,lNy-1) )

! Compute first derivatives on the staggered grid
do j=1,lNy-1
	do i=1,lNx-1			
		dtdx(i,j) = ( lT(i+1,j)-lT(i,j) + lT(i+1,j+1)-lT(i,j+1) )/(2._dp*lDx)
		dtdy(i,j) = ( lT(i,j+1)-lT(i,j) + lT(i+1,j+1)-lT(i+1,j) )/(2._dp*lDy)
	end do 
end do 

! Compute second derivatives on the staggered grid, dealing with boundaries
!! x-dir^2
dtdxx(1,:) = (dtdx(2,:)-dtdx(1,:))/lDx  
dtdxx(2:lNx-2,:) = (dtdx(3:lNx-1,:)-dtdx(1:lNx-3,:))/(2._dp*lDx) 
dtdxx(lNx-1,:) = (dtdx(lNx-1,:)-dtdx(lNx-2,:))/lDx 
!! x-dir*y-dir
dtdxy(1,:) = (dtdy(2,:)-dtdy(1,:))/lDx  
dtdxy(2:lNx-2,:) = (dtdy(3:lNx-1,:)-dtdy(1:lNx-3,:))/(2._dp*lDx)
dtdxy(lNx-1,:) = (dtdy(lNx-1,:)-dtdy(lNx-2,:))/lDx 
!! y-dir^2
dtdyy(:,1) = (dtdy(:,2)-dtdy(:,1))/lDy 
dtdyy(:,2:lNy-2) = (dtdy(:,3:lNy-1)-dtdy(:,1:lNy-3))/(2._dp*lDy) 
dtdyy(:,lNy-1) = (dtdy(:,lNy-1)-dtdy(:,lNy-2))/lDy 

deallocate( dtdx, dtdy )
return
end subroutine spatial2ndDerivSg

! ==================================================================================================
! trackIceVol: Keep track of ice volume input and loss during each step of the ice model
! ==================================================================================================
subroutine trackIceVol( dvolSrc, dvolSnk, proc, lastProc, jSta, jEnd, lNx, lNy, lDx, lDy, qx, qy, &
	lSnow, lMelt, timeStep)

! Arguments:
!! dvolSrc, dvolSnk (inout): ice volume added, lost by boundary flux and climate, m^3
!! proc (in): integer label for this thread
!! lastProc (in): integer label for the last thread
!! jSta, jEnd (in): indices of the rows handled by this thread
!! lNx, lNy (in): low-res grid dimensions
!! lDx, lDy (in): low-res grid spacing, m
!! qx (in): x-direction ice flux, on a staggered grid, m^2/yr
!! qy (in): y-direction ice flux, on a staggered grid, m^2/yr
!! lSnow (in): snowfall, m_ice
!! lMelt (in): ice melt, m_ice
!! timeStep (in): ice model timestep, yr

integer, intent(in) :: proc, lastProc, jSta, jEnd, lNx, lNy
real(dp), intent(in) :: lDx, lDy, qx(:,:), qy(:,:), lSnow(:,:), lMelt(:,:), timeStep
real(dp), intent(inout) :: 	dvolSrc, dvolSnk

integer :: j0, j1

! Boundary ice flux
j0 = max(1,jSta-1); j1 = min(lNy-2,jEnd-1) ! qx ranges
!! Sources
dvolSrc = dvolSrc + sum( qx(1,j0:j1), mask=qx(1,j0:j1)>0._dp )*lDy*timeStep 
dvolSrc = dvolSrc - sum( qx(lNx-1,j0:j1), mask=qx(lNx-1,j0:j1)>0._dp )*lDy*timeStep 		
if (proc==0) dvolSrc = dvolSrc + sum( qy(:,1), mask=qy(:,1)>0._dp )*lDx*timeStep
if (proc==lastProc) dvolSrc = dvolSrc - sum( qy(:,lNy-1), mask=qy(:,lNy-1)>0._dp )*lDx*timeStep
!! Sinks
dvolSnk = dvolSnk + sum( qx(1,j0:j1), mask=qx(1,j0:j1)<0._dp )*lDy*timeStep		
dvolSnk = dvolSnk - sum( qx(lNx-1,j0:j1), mask=qx(lNx-1,j0:j1)<0._dp )*lDy*timeStep		
if (proc==0) dvolSnk = dvolSnk + sum( qy(:,1), mask=qy(:,1)<0._dp )*lDx*timeStep
if (proc==lastProc) dvolSnk = dvolSnk - sum( qy(:,lNy-1), mask=qy(:,lNy-1)<0._dp )*lDx*timeStep

! Accumulation/ablation
j0 = max(2,jSta); j1 = min(lNy-1,jEnd) ! interior points only
!! Sources
dvolSrc = dvolSrc + sum( lSnow(2:lNx-1,j0:j1), mask=lSnow(2:lNx-1,j0:j1)>0._dp )*lDx*lDy  
!! Sinks
dvolSnk = dvolSnk + sum( lSnow(2:lNx-1,j0:j1), mask=lSnow(2:lNx-1,j0:j1)<0._dp )*lDx*lDy ! for benchmarks
dvolSnk = dvolSnk - sum( lMelt(2:lNx-1,j0:j1) )*lDx*lDy 		

return
end subroutine trackIceVol

! ==================================================================================================
! smoothGrid: 9-pt weighted average smoothing filter
! ==================================================================================================
subroutine smoothGrid( arr )

! Arguments:
!! arr (inout) = the array to be smoothed

real(dp), intent(inout) :: arr(:,:)

integer :: nx, ny, i, j
real(dp), allocatable :: work(:,:)

! Get grid size
nx = size(arr,1)
ny = size(arr,2)
allocate( work(nx+2,ny+2) )

! Populate working array
work(2:nx+1,2:ny+1) = arr
work(1,:) = work(2,:)
work(nx+2,:) = work(nx+1,:)
work(:,1) = work(:,2)
work(:,ny+2) = work(:,ny+1)

! Filter
do j=2,ny+1
	do i=2,nx+1
		work(i,j) = ( 8._dp*work(i,j) + 2._dp*work(i-1,j) + 2._dp*work(i+1,j) + 2._dp*work(i,j-1) +&
			2._dp*work(i,j+1) + work(i-1,j-1) + work(i-1,j+1) + work(i+1,j-1) + work(i+1,j+1) )/20._dp
	end do
end do

! Copy smoothed points back to the input array
arr = work(2:nx+1,2:ny+1)
	
return 
end subroutine smoothGrid

end module ice
