module cascade

use types, only: dp, sp
implicit none
private
public runCascade

! Cascade fluvial model. Modified from Braun et al 1997, Basin Research. Modifications include 
! manual computation of the neighbor network for a regular rectangular grid, a simple stream-
! power erosion law (sediment is not tracked and deposition is ignored), and a rejiggered treatment 
! of the domain boundaries.

! Module contains:
!! runCascade: the "parent" subroutine used to run the model 
!! findNeighbors: find neighbors in a regular grid, including cyclic boundaries
!! findOutlets: labels outlet points based on the selected boundary conditions
!! findOrder: calculate the proper ordering of nodes for the river erosion calculations
!! findDonors: finds the lowest neighbour of each point among its natural neighbours, and the 
!!! slope and distance to the neighbor.
!! findCatchment: finds the distribution of catchment areas, their sills, and the distribution of "lakes"
!! arrayToVector: copy an array row-by-row into a vector (overloaded for double, integer, and logical)
!! vectorToArray: copy a vector into an array row-by-row (overloaded for double, integer, and logical)

! "Hungarian" prefixes are used to indicate the intended usage of the variable:
!! p -> input parameter
!! g -> 2D grid
!! v -> 1D vector

! Version info (auto-generated by svn):
!! $LastChangedDate: 2014-05-08 23:10:37 -0400 (Thu, 08 May 2014) $
!! $LastChangedBy: kfm $
!! $LastChangedRevision: 92 $ 

! Subroutine overloading, to deal with different variable types
interface arrayToVector
	module procedure arrayToVector_dp, arrayToVector_int, arrayToVector_lg  
end interface
interface vectorToArray
	module procedure vectorToArray_dp, vectorToArray_int, vectorToArray_lg
end interface

! Option flags
logical, parameter :: check_water_cons = .false. ! check for water conservation, print to screen

contains

! ==================================================================================================
! runCascade: main fluvial model, computes water routing (including lakes) and fluvial erosion rate
! ==================================================================================================
subroutine runCascade ( gH, dx, dy, pBcN, pBcS, pBcE, pBcW, pErosFact, pBaseLvl, gIceFree, &
	gQWater, gSlope, gLake, gCatchment, gErosRate, ierr )

! Arguments: 
!! gH (in) = topography grid
!! dx, dy (in) = grid spacing for the topography grid (same units as gH)
!! pBcN, pBcS, pBcE, pBcW (in) = n,s,e,w fluvial boundary conditions (0=open, 1=closed, 2=cyclic)
!! pErosFact (in) = stream power erosion constant (note the exponent is assumed=0.5)
!! pBaseLvl (in) = base-level elevation
!! gIceFree (in) = logical grid indicating points covered by glaciers (.false.) and not (.true.)
!! gQWater (inout) = discharge of water at each point, the input variable contains the water 
!!! generation rate for the point (rainfall+ice melt), the output variable contains the accumulate 
!!! flow through the drainage network 
!! gSlope (out) = slope to lowest neighbor (m/m)
!! gLake (out) = logical flag indicating whether a point is in a lake (.true.) or not (.false.)
!! gCatchment (out) = catchments to which each point belongs, named after the linear index to the 
!!! catchment minimum point
!! gErosRate (out) = fluvial erosion rate
!! ierr (out) = error flag for debugging

logical, intent(in) :: gIceFree(:,:)
integer, intent(in) :: pBcN, pBcS, pBcE, pBcW
real(dp), intent(in) :: gH(:,:), dx, dy, pErosFact, pBaseLvl

real(dp), intent(inout) :: gQWater(:,:)

logical, intent(out) :: gLake(:,:)
integer, intent(out) :: gCatchment(:,:), ierr
real(dp), intent(out) :: gSlope(:,:), gErosRate(:,:)

logical, allocatable :: vOutlet(:), gOutlet(:,:), vLake(:)
integer :: nx, ny, npts, k, i
integer, allocatable :: vDonor(:), vCatchment(:), order(:)
real(dp) :: waterin, waterout
real(dp), allocatable :: vH(:), vSlope(:), vQWater(:)

! Saved variables, created on the first call then re-used in subsequent calls
integer, allocatable, save :: nbrList(:,:), nbrNum(:)
real(dp), allocatable, save :: nbrDist(:,:)

! Allocate vectors
nx = size(gH,1)
ny = size(gH,2)
npts = nx*ny
allocate( vDonor(npts), vH(npts), vSlope(npts), vCatchment(npts), vLake(npts), gOutlet(nx,ny), &
	vOutlet(npts), order(npts), vQWater(npts) )

call arrayToVector( gH, vH )

! Find neighbors of each point	
!! Note: this step need only be run one time. To do this, the output arguments are saved between 
!!! calls to the runCascade subroutine, and the following lines are skipped if those arrays are 
!!! already allocated.
if (allocated(nbrList) .eqv. .false.) then
	call findNeighbors( nx, ny, dx, dy, pBcN, pBcS, pBcE, pBcW, nbrList, nbrNum, nbrDist )	
end if	

! Designate the outlet points 
call findOutlets (pBcN, pBcS, pBcE, pBcW, gOutlet )

! Convert to vectors 
!call arrayToVector( gH, vH )
call arrayToVector( gOutlet, vOutlet )
call arrayToVector( gQWater, vQWater )

! Find donors (downslope neighbors) and slope 
call findDonors( vH, nbrNum, nbrList, nbrDist, vDonor, vSlope )

! Connect catchments and find lakes
call findCatchment( vDonor, vCatchment, vLake, nbrList, nbrNum, nbrDist, vOutlet, vH, vSlope, ierr )

! Get the proper ordering
call findOrder ( vDonor, order )

! Accumulate discharge 
do k = 1,npts
	i = order(k)
	if (vDonor(i)/=i) vQWater(vDonor(i)) = vQWater(vDonor(i)) + vQWater(i)
end do

! Optional: Check for water conservation
if (check_water_cons) then
	waterin = sum(gQWater) ! retains the input vals until vectorToArray is called
	waterout = 0. ! accumulate discharge from outlet self-donors
	do k = 1,npts
		if ((vDonor(k)==k).and.(vOutlet(k) .eqv. .true.)) waterout = waterout + vQWater(k)
	end do
	print*,'water in, out, frac diff:', real(waterin,sp), real(waterout,sp), &
		real((waterin-waterout)/waterin,sp)
end if

! Convert to arrays
call vectorToArray (vSlope, gSlope)
call vectorToArray (vLake, gLake)
call vectorToArray (vCatchment, gCatchment)
call vectorToArray (vQWater, gQWater)

! Impose lakes at base-level
where (gH<=pBaseLvl) gLake=.true.

! Compute fluvial erosion rate
where (gLake .eqv. .false. .and. gIceFree .eqv. .true.)
	gErosRate = -gSlope*gQWater**0.5_dp*pErosFact
elsewhere
	gErosRate = 0._dp
end where

! Deallocate
deallocate( vDonor, vH, vSlope, vLake, vCatchment, gOutlet, vOutlet, order, vQWater )

return
end subroutine runCascade

! ==================================================================================================
! findNeighbors: find neighbors in a regular grid of the given dimensions
! ==================================================================================================
subroutine findNeighbors ( nx, ny, dx, dy, nbc, sbc, ebc, wbc, nbrList, nbrNum, nbrDist )

! Arguments:
!! nx, ny (in) = dimensions of the regular grid for which to find neighbors
!! dx, dy (in) = grid spacing of the regular grid
!! nbc, sbc, ebc, wbc (in) = integer labels for the 4 boundary conditions
!! nbrList (out) = neighbor list (allocatable, allocated in this subroutine)
!! nbrNum (out) = number of neighbors for each point (allocatable, allocated in this subroutine)
!! nbrDist (out) = distance to each neighbor in the list (allocatable, allocated in this subroutine)

integer, intent(in) :: nx, ny, nbc, sbc, ebc, wbc
real(dp), intent(in) :: dx, dy
integer, allocatable, intent(out) :: nbrList(:,:), nbrNum(:)
real(dp), allocatable, intent(out) :: nbrDist(:,:)

integer :: i, j, k, n, ks, kn, kw, ke, ind(nx,ny), iOff(8), jOff(8), inbr, jnbr
real(dp) :: diag, dOff(8)

! Create an array filled with linear indices
do j = 1,ny
	do i = 1,nx
		ind(i,j) = (j-1)*nx+i
	end do 
end do

! Allocate outputs
allocate( nbrList(8,nx*ny), nbrNum(nx*ny), nbrDist(8,nx*ny) )
nbrList = 0
nbrNum = 0
nbrDist = 0._dp

! Define offsets to 8-neighbors
iOff = [-1, 0, 1, -1, 1, -1, 0, 1] ! x-subscript offset
jOff = [1, 1, 1, 0, 0, -1, -1, -1] ! y-subscript offset 
diag = sqrt(dx**2+dy**2)
dOff = [ diag, dy, diag, dx, dx, diag, dy, diag ] ! distance offset

! Populate neighbor lists
do i = 1,nx
	do j = 1,ny
		k = (j-1)*nx+i		
		do n = 1,8
			inbr = i+iOff(n)
			jnbr = j+jOff(n)
			!! If the neighbor exists, add it to the list
			if ( (inbr>=1).and.(inbr<=nx).and.(jnbr>=1).and.(jnbr<=ny) ) then
				nbrNum(k) = nbrNum(k)+1
				nbrList(nbrNum(k),k) = ind(inbr,jnbr)
				nbrDist(nbrNum(k),k) = dOff(n)
			end if
		end do
				
	end do 
end do

! Add neighbors at cyclic boundaries
!! North-south cyclic
if ((nbc==2).and.(sbc==2)) then
	dOff = [ diag, dy, diag, 0._dp, 0._dp, 0._dp, 0._dp, 0._dp ] 
	do i = 1,nx
		ks = i ! south, j-->1
		kn = (ny-1)*nx+i ! north, j-->ny
		
		
!		! DEBUG: Check the added neighbors and the associated distances
!		print*,'before',i,1			
!		do nn=1,nbrNum(ks)			
!			knn = nbrList(nn,ks)
!			print*,	mod(knn-1,nx)+1, (knn-1)/nx+1, nbrDist(nn,ks), vH(ks)-vH(knn)
!		end do
		
		do n = -1,1
			inbr = i+n
			if ( inbr>=1 .and. inbr<=nx ) then
				!!!Northern edge
				nbrNum(ks) = nbrNum(ks)+1
				nbrList(nbrNum(ks),ks) = ind(inbr,ny) ! south, jnbr-->ny
				nbrDist(nbrNum(ks),ks) = dOff(n+2)
				!!! Southern edge
				nbrNum(kn) = nbrNum(kn)+1
				nbrList(nbrNum(kn),kn) = ind(inbr,1) ! north, jnbr-->1
				nbrDist(nbrNum(kn),kn) = dOff(n+2)
			end if
		end do
		
!		! DEBUG: Check the added neighbors and the associated distances
!		print*,'after',i,1			
!		do nn=1,nbrNum(ks)
!			knn = nbrList(nn,ks)
!			print*,	mod(knn-1,nx)+1, (knn-1)/nx+1, nbrDist(nn,ks), vH(ks)-vH(knn)
!		end do
					
	end do
end if
	
!! East-west cyclic
if ((ebc==2).and.(wbc==2)) then
	dOff = [ diag, dx, diag, 0._dp, 0._dp, 0._dp, 0._dp, 0._dp ] 	
	do j = 1,ny
		kw = (j-1)*nx+1 ! west, i-->1
		ke = (j-1)*nx+nx ! east, i-->nx
		do n = -1,1
			jnbr = j+n
			if ( jnbr>=1 .and. jnbr<=ny ) then
				!!! Western edge
				nbrNum(kw) = nbrNum(kw)+1
				nbrList(nbrNum(kw),kw) = ind(nx,jnbr) ! west, inbr-->nx
				nbrDist(nbrNum(kw),kw) = dOff(n+2)
				!!! Eastern edge
				nbrNum(ke) = nbrNum(ke)+1
				nbrList(nbrNum(ke),ke) = ind(1,jnbr) ! east, inbr-->1
				nbrDist(nbrNum(ke),ke) = dOff(n+2)
			end if
		end do
	end do

end if

end subroutine findNeighbors

! ==================================================================================================
! findOutlets: labels outlet points based on the selected boundary conditions
! ==================================================================================================
subroutine findOutlets (pBcN, pBcS, pBcE, pBcW, gOutlet )

! Arguments:
!! pBcN, pBcS, pBcE, pBcW (in)  = integer flags indicate the BC to apply for each boundary
!! gOutlet (out) = logicals indicating if a point is an outlet (.true.) or not (.false.)

! Note: the possible boundary conditions are...
!! open (0) -> copy adjacent interior points out and subtract a little, set outlet flag
!! closed (1) -> copy adjacent interior points out and add a little, leave outlet flag as 0
!! cyclic (2) -> set boundary points to the elvation of the interior points at the opposing edge

integer, intent(in) :: pBcN, pBcS, pBcE, pBcW
logical, intent(out) :: gOutlet(:,:)

integer :: nx, ny

nx = size(gOutlet,1)
ny = size(gOutlet,2)

! Start with no outlets, then add them at open boundaries
gOutlet = .false. 

! Open boundaries
if (pBcN==0) gOutlet(:,ny) = .true.	
if (pBcS==0) gOutlet(:,1) = .true.	
if (pBcE==0) gOutlet(nx,:) = .true.	
if (pBcW==0) gOutlet(1,:) = .true.	

! Closed boundaries
!! No outlets to mark, do nothing

! Cyclic boundaries
!! No outlets to mark, do nothing

return
end subroutine findOutlets

! ==================================================================================================
! findDonors: finds the lowest neighbour of each point among its neighbours and the slope to it
! ==================================================================================================
subroutine findDonors( vH, nbrNum, nbrList, nbrDist, vDonor, vSlope )

! Arguments:
!! vH (in) = present topography
!! nbrNum (in) = number of neighbours per node
!! nbrList (in) = list of neighbours per node
!! nbrDist (in) = distance to each nieghbor given in nbrList
!! vSlope (out) = slope of stream segment originating at node i
!! vDonor (out) = donor of node i (ie where the segment ends)

! Note: Finds the lowest neighbour of each point among its natural neighbours and the slope to that 
!! neighbor. Converted from fixed- to free-form fortran and modified to use pre-computed lengths 
!! by KFM.

integer, intent(in) :: nbrNum(:), nbrList(:,:)
real(dp), intent(in) :: vH(:), nbrDist(:,:)

integer, intent(out) :: vDonor(:)
real(dp), intent(out) :: vSlope(:)

integer :: k, n, kNbr
real(dp) :: dh, dd, s

! Loop over the nodes
do k = 1,size(nbrNum)
	vSlope(k) = 0._dp
	vDonor(k) = k ! start with the assumption that the point is a self-donor (local minimum)
	!! Loop over the neighbours
	do n = 1,nbrNum(k)
		kNbr = nbrList(n,k)
		dd = nbrDist(n,k)
		dh = vH(kNbr)-vH(k)
		s = dh/dd
		if (s<vSlope(k)) then
			vDonor(k) = kNbr
			vSlope(k) = s
		endif
	enddo
enddo

return
end subroutine findDonors

! ==================================================================================================
! findOrder: calculate the proper ordering of nodes for the river erosion calculations
! ==================================================================================================
subroutine findOrder ( vDonor, order )

! Arguments:
!! vDonor (in): donor vector
!! Order (in): node ordering

integer, intent(in) :: vDonor(:)
integer, intent(out) :: order(:)

logical :: more
integer :: n, norder, i, ib
integer, allocatable :: bucket(:)

!! Allocate
n = size(vDonor)
allocate( bucket(n) )

norder = 0

do i = 1,n
	bucket(i) = 1
	if (vDonor(i).eq.i) bucket(i) = 0
end do

!! Beginning of pseudo time stepping
more = .true.
do while (more .eqv. .true.)

	do i = 1,n
		if (bucket(i).ne.0) bucket(vDonor(i)) = -1
	enddo
	
	more = .false.
	do i = 1,n
		ib = bucket(i)
		if (ib.gt.0) then
			norder = norder+1
			order(norder) = i
			ib = 0
			more = .true.
		endif
		bucket(i) = ib**2
	enddo

end do 

do i = 1,n
	if (vDonor(i).eq.i) then
		norder = norder+1
		order(norder) = i
	endif
enddo

!! Deallocate
deallocate( bucket )

return
end subroutine findOrder

! ==================================================================================================
! findCatchment: finds the catchments, their sills, and lakes
! ==================================================================================================
subroutine findCatchment( vDonor, vCatchment, vLake, nbrList, nbrNum, nbrDist, vOutlet, vH, vSlope, ierr )

! Note: A catchment area is characterized by a minimum in topography, every node is part of a 
!! catchment area. vCatchment(i) is the node number of the minimum in which node i is draining. 
!! vLake(i) is 0 if node i is not in a lake and 1 if node i is in a lake. Code converted from 
!! fixed- to free-form fortran, and modified slightly by KFM

! Arguments:
!! nbrList (in) = neighbour array
!! nbrNum (in) = number of neighbour per node
!! nbrDist (in) = distance to each neighbor in nbrList
!! vH (in) = present topography
!! vOutlet (in) = boundary condition vector, 1 if water can exit here, 0 if not
!! vDonor (inout) = index of downslope neighbor, modified to connect subcatchments across sill points
!! vSlope (inout) = modified at sill points
!! vCatchment (out) = catchment vector
!! vLake (out) = lake vector
!! ierr (out) = error flag, used for debugging

logical, intent(in) :: vOutlet(:)
integer, intent(in) :: nbrNum(:), nbrList(:,:)
real(dp), intent(in) :: nbrDist(:,:)

integer, intent(inout) :: vDonor(:)
real(dp), intent(inout) :: vH(:), vSlope(:) ! vH is only preturbed minutely if it is nec. to find a sill 

logical, intent(out) :: vLake(:)
integer, intent(out) :: vCatchment(:), ierr

logical :: done
integer :: n, noise, nl, nd, nnn, i, j, nc, jjj, k, kk, mmm, ik
integer, allocatable :: work(:)
real(dp) :: hMax, hMin, randNum, slopeMin, length, slope

! Allocate
n = size(vDonor)
allocate( work(n) )

! Init values
vLake = .false.
vCatchment = 0
hMax = maxval(vH)
do i = 1,n
	work(i) = i
end do

! Find catchment names
nnn = 1
do while (nnn>0)
	nnn = 0
	do i = 1,n
		!! No catchment yet found for this point
		if (vCatchment(i).eq.0) then 
			nl = work(i)
			nd = vDonor(nl)
			!! Found the catchment
			if (nd.eq.nl) then
				vCatchment(i) = nl
			!! Keep looking
			else
				work(i) = nd
				nnn = nnn+1
			endif
		endif
	end do
end do

! Find sills & lakes, consolidate catchments
noise = 0
172 continue
done = .false.
do while (done .eqv. .false.)

	!! Reset
	done = .true. 	
	do i = 1,n
		work(i) = 0
	enddo
	
	!! Catchments that are connected to an outlet are finished
	do i = 1,n
		if (vOutlet(i) .eqv. .true.) then
			nc = vCatchment(i)
			work(nc) = 1
		endif
	enddo
	
	!! Finds sills
	do i = 1,n
		nc = vCatchment(i)
		if (work(nc).eq.0) then ! no sill yet
			done = .false.
			!! Look for the lowest point on the catchment boundary that has a donor below it
			hMin = hMax
			jjj = 0
			do j = 1,n
				if (vCatchment(j).eq.nc) then
					do k = 1,nbrNum(j)
						nnn = nbrList(k,j)
						if (vCatchment(nnn).ne.nc .and.vH(nnn).lt.vH(j)) then
							if (vH(j).lt.hMin) then
								hMin = vH(j)
								jjj = j
							endif
						endif
					enddo
				endif
			enddo
			!! Sometimes one has to look at a second ring of nodes, i.e. neighbours of neighbours
			if (jjj.eq.0) then
				do j = 1,n
					if (vCatchment(j).eq.nc) then
						do k = 1,nbrNum(j)
							nnn = nbrList(k,j)
							if (vCatchment(nnn).ne.nc) then
								do kk = 1,nbrNum(nnn)
									mmm = nbrList(kk,nnn)
									if (vCatchment(mmm).ne.nc .and. vH(mmm).lt.vH(nnn)) then
										if (vH(nnn).lt.hMin) then
											hMin = vH(nnn)
											jjj = nnn
										endif
									endif
								enddo
							endif
						enddo
					endif
				enddo
			endif
			!! Otherwise give up...
			if (jjj.eq.0) then
				print*,'cannot find a sill, added some noise to try to fix it.'
				noise = noise+1
				do ik = 1,n
					call random_number(randNum)
					vH(ik) = vH(ik)+randNum*1.e-4
				enddo
				!!! Cannot resolve the sill, water will not be conserved
				if (noise==5) then 
					print*,'Cannot resolve a catchment sill , water will not be conserved, exiting.'
					print*,'Problem catchment = ',nc
					ierr = nc
					return
				!!! Try again	
				else 
					goto 172
				end if
			endif
			!! A sill has been found in node jjj
			!!! Now find the neighbours that is in another catchment and has the steepest slope
			slopeMin = 0.
			do k = 1,nbrNum(jjj)
				nnn = nbrList(k,jjj)
				if (vCatchment(nnn).ne.nc .and. nnn.ne.jjj) then
					length = nbrDist(k,jjj)
					!if (length.eq.0) print*,nnn,jjj
					slope = (vH(nnn)-vH(jjj))/length
					if (slope.lt.slopeMin) then
						slopeMin = slope
						vDonor(nc) = nnn
						vSlope(nc) = slope
					endif
				endif
			enddo
			!! Find lake nodes in this catchment
			do k = 1,n
				if (vCatchment(k).eq.nc .and. vH(k).lt.vH(jjj)) vLake(k) = .true. 
			enddo
			!! Reset catchment names
			do k = 1,n
				if (vCatchment(k).eq.nc) vCatchment(k) = vCatchment(vDonor(nc))
			enddo
		endif
	enddo
end do

deallocate( work )

return
end subroutine findCatchment

! ==================================================================================================
! arrayToVector: copy an array row-by-row into a vector (overloaded)
! ==================================================================================================
subroutine arrayToVector_dp ( array, vector )
! Double precision version.

! Arguments:
!! array (in) = input array, double precision
!! vector (out) = output vector, double precision

real(dp), intent(in) :: array(:,:)
real(dp), intent(out) :: vector(:)

integer :: i, j, k, nx, ny

nx = size(array,1)
ny = size(array,2)

do j=1,ny
	do i=1,nx
		k = (j-1)*nx+i
		vector(k)=array(i,j)
	enddo
enddo

return
end subroutine arrayToVector_dp

subroutine arrayToVector_int ( array, vector )
! Integer version

! Arguments:
!! array (in) = input array, integer
!! vector (out) = output vector, integer

integer, intent(in) :: array(:,:)
integer, intent(out) :: vector(:)

integer :: i, j, k, nx, ny

nx = size(array,1)
ny = size(array,2)

do j=1,ny
	do i=1,nx
		k = (j-1)*nx+i
		vector(k)=array(i,j)
	enddo
enddo

return
end subroutine arrayToVector_int

subroutine arrayToVector_lg ( array, vector )
! Logical version

! Arguments:
!! array (in) = input array, logical
!! vector (out) = output vector, logical

logical, intent(in) :: array(:,:)
logical, intent(out) :: vector(:)

integer :: i, j, k, nx, ny

nx = size(array,1)
ny = size(array,2)

do j=1,ny
	do i=1,nx
		k = (j-1)*nx+i
		vector(k)=array(i,j)
	enddo
enddo

return
end subroutine arrayToVector_lg

! ==================================================================================================
! vectorToArray: copy a vector into an array row-by-row (overloaded)
! ==================================================================================================
subroutine vectorToArray_dp ( vector, array )
! Double precision version.

! Arguments:
!! vector (in) = output vector, double precision
!! array (out) = input array, double precision

real(dp), intent(in) :: vector(:)
real(dp), intent(out) :: array(:,:)

integer :: i, j, k, n, nx

n = size(vector)
nx = size(array,1)

do k=1,n
	i = mod(k-1,nx)+1
	j = (k-1)/nx+1
	array(i,j) = vector(k)
end do

return
end subroutine vectorToArray_dp

subroutine vectorToArray_int ( vector, array )
! Integer version

! Arguments:
!! vector (in) = output vector, integer
!! array (out) = input array, integer

integer, intent(in) :: vector(:)
integer, intent(out) :: array(:,:)

integer :: i, j, k, n, nx

n = size(vector)
nx = size(array,1)

do k=1,n
	i = mod(k-1,nx)+1
	j = (k-1)/nx+1
	array(i,j) = vector(k)
end do

return
end subroutine vectorToArray_int

subroutine vectorToArray_lg ( vector, array )
! Logical version

! Arguments:
!! vector (in) = output vector, integer
!! array (out) = input array, integer

logical, intent(in) :: vector(:)
logical, intent(out) :: array(:,:)

integer :: i, j, k, n, nx

n = size(vector)
nx = size(array,1)

do k=1,n
	i = mod(k-1,nx)+1
	j = (k-1)/nx+1
	array(i,j) = vector(k)
end do

return
end subroutine vectorToArray_lg


end module

